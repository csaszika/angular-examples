{
  "version": 3,
  "sources": [
    "webpack:///./node_modules/@angular/cdk/esm5/text-field.es5.js",
    "webpack:///./node_modules/@angular/material/esm5/chips.es5.js",
    "webpack:///./node_modules/@angular/material/esm5/form-field.es5.js",
    "webpack:///./node_modules/@angular/material/esm5/input.es5.js",
    "webpack:///./node_modules/@angular/material/esm5/radio.es5.js",
    "webpack:///./node_modules/@angular/material/esm5/select.es5.js",
    "webpack:///./node_modules/@angular/material/form-field/typings/index.d.ts.MatFormField.html",
    "webpack:///./node_modules/@angular/material/select/typings/index.d.ts.MatSelect.html"
  ],
  "names": [],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACmD;AACjF;AACJ;AACD;;AAE/B;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA,eAAe,EAAE,uHAAyD,gBAAgB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA,6BAA6B,oBAAoB,EAAE,wCAAwC;AAC3F;AACA;AACA;AACA,6BAA6B,oBAAoB,EAAE,yCAAyC;AAC5F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mEAAmE,sCAAsC,EAAE;AAC3G;AACA;AACA,SAAS,yEAA2B,qBAAqB,IAAI;AAC7D;AACA;AACA,kDAAkD;AAClD,SAAS,wEAAkB;AAC3B,SAAS,8DAAgB;AACzB,MAAM;AACN,iIAA2E,8CAA8C,8QAA8D,EAAE,8CAA8C;AACvO;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,yCAAyC,sCAAsC,EAAE;AACjF;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,8CAA8C;AAC9C,SAAS,kEAAoB;AAC7B,SAAS,yBAAyB;AAClC,MAAM;AACN;AACA,yBAAyB,6DAAe;AACxC;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,sBAAsB,EAAE;AAC7C;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,sBAAsB,EAAE;AAC7C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,sBAAsB,EAAE;AAC7C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uCAAuC,EAAE;AACrF,aAAa;AACb;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE,+BAA+B,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY,EAAE;AAC9D;AACA,4DAA4D,YAAY,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE,0BAA0B,EAAE;AACrD,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,IAAI;AACrB;AACA;AACA,sDAAsD;AACtD,SAAS,kEAAoB;AAC7B,SAAS,wEAAkB;AAC3B,SAAS,8DAAgB;AACzB,MAAM;AACN;AACA,qBAAqB,2FAA6C;AAClE,qBAAqB,2FAA6C;AAClE,qBAAqB,4FAA8C;AACnE;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/gBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;AACY;AACU;AACvB;AACyN;AACrG;AAChG;AACb;AACD;AACA;AACuB;AAClB;AACV;;AAEpB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B;AAC3B,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B;AAC3B,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,qBAAqB,EAAE;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oDAAoD,EAAE;AAC3E;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,wBAAwB,EAAE;AAC/C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,uEAAuE,oCAAoC;AAC3G;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA,oBAAoB,EAAE;AACtB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,IAAI;AACrB;AACA;AACA,0CAA0C;AAC1C,SAAS,kEAAoB;AAC7B,SAAS,8DAAgB;AACzB,SAAS,wEAAkB;AAC3B,SAAS,gCAAgC,+DAAiB,GAAG,wJAAmD,IAAI;AACpH,MAAM;AACN;AACA,oBAAoB,2FAA6C;AACjE,0BAA0B,iGAAmD;AAC7E,wBAAwB,wJAAoD,sBAAsB,EAAE,KAAK;AACzG,sBAAsB,4DAAc;AACpC,mBAAmB,4DAAc;AACjC,wBAAwB,4DAAc;AACtC,uBAAuB,4DAAc;AACrC,6BAA6B,6DAAe;AAC5C,uBAAuB,6DAAe;AACtC,qBAAqB,6DAAe;AACpC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,gDAAgD;AAChD,SAAS,iBAAiB;AAC1B,MAAM;AACN;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA,eAAe,EAAE;;AAEjB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,sCAAsC,EAAE;AAC7D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,0BAA0B,EAAE;AACjD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oBAAoB,EAAE;AAC3C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oDAAoD,uBAAuB,EAAE;AAC7E;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oCAAoC,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oEAAoE,EAAE;AAC3F;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,6GAA+C,EAAE;AAC3E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,yBAAyB,EAAE;AAChD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,oDAAoD,oDAAoD,EAAE;AAC1G;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,4GAAuE,6BAA6B,EAAE;AACtG,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,4GAAuE,sBAAsB,EAAE;AAC/F,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,4GAAuE,qBAAqB,EAAE;AAC9F,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,4GAAuE,uBAAuB,EAAE;AAChG,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAmD,EAAE;AACzF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE,wBAAwB,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE,uBAAuB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA,4CAA4C,wBAAwB,EAAE;AACtE;AACA,mDAAmD,sDAAsD,EAAE;AAC3G;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD,uBAAuB,EAAE;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,6DAA6D,mBAAmB,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS,wEAA0B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iCAAiC,uHAAyD;AAC1F,wCAAwC,kBAAkB,gBAAgB,sBAAsB,mBAAmB,oDAAoD,oBAAoB,iBAAiB,mBAAmB,mBAAmB,eAAe,6CAA6C,WAAW,YAAY,yBAAyB,iGAAiG,UAAU,6CAA6C,mBAAmB,mBAAmB,4GAA4G,cAAc,iBAAiB,oEAAoE,kBAAkB,eAAe,8EAA8E,iBAAiB,gBAAgB,+CAA+C,gBAAgB,mBAAmB,kBAAkB,kBAAkB,yDAAyD,iBAAiB,mBAAmB,wCAAwC,eAAe,mBAAmB,kDAAkD,gBAAgB,kBAAkB,oCAAoC,WAAW,YAAY,iBAAiB,cAAc,8CAA8C,gBAAgB,eAAe,+EAA+E,WAAW,YAAY,eAAe,+EAA+E,gBAAgB,eAAe,mGAAmG,iBAAiB,cAAc,uBAAuB,aAAa,mBAAmB,eAAe,mBAAmB,YAAY,yFAAyF,WAAW,8CAA8C,sBAAsB,uBAAuB,iEAAiE,WAAW,iBAAiB,kBAAkB,uBAAuB,mBAAmB,aAAa,gBAAgB,qBAAqB,YAAY,WAAW,eAAe;AAC7wE;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,8CAA8C;AAC9C,SAAS,kEAAoB;AAC7B,SAAS,yEAA2B;AACpC,SAAS,uFAAqC,+DAAiB,IAAI;AACnE,SAAS,6EAA6B,+DAAiB,IAAI;AAC3D,SAAS,yFAAyC,+DAAiB,IAAI;AACvE,SAAS,kFAA2B;AACpC,SAAS,gFAAgC,+DAAiB,GAAG,2DAAa,IAAI;AAC9E,MAAM;AACN;AACA,+BAA+B,4DAAc;AAC7C,sBAAsB,4DAAc;AACpC,yBAAyB,4DAAc;AACvC,mBAAmB,4DAAc;AACjC,sBAAsB,4DAAc;AACpC,yBAAyB,4DAAc;AACvC,sBAAsB,4DAAc;AACpC,6BAA6B,yFAA2C;AACxE,wBAAwB,4DAAc;AACtC,sBAAsB,4DAAc;AACpC,oBAAoB,6DAAe;AACnC,yBAAyB,6DAAe;AACxC,mBAAmB,wFAA0C;AAC7D;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,wBAAwB,EAAE;AAC/C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,8GAAgD,EAAE;AAC5E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,kCAAkC,EAAE;AACzD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAA6D;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,4BAA4B;AAC7C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,+CAA+C;AAC/C,SAAS,kEAAoB;AAC7B,SAAS,gCAAgC,iGAAmD,IAAI;AAChG,MAAM;AACN;AACA,sBAAsB,wFAA0C;AAChE,uBAAuB,8FAAgD;AACvE,+BAA+B,sGAAwD;AACvF,qBAAqB,8FAAgD;AACrE,yBAAyB,4DAAc;AACvC,gBAAgB,4DAAc;AAC9B;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1zDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACuM;AAClJ;AACjC;AACK;AACO;AACe;AACb;AACR;AACP;AACI;;AAEvB;AACA;AACA,cAAc,WAAW;AACzB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA,gBAAgB,4DAAc;AAC9B;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,sJAA8B,0CAA0C;AACxE;AACA,+EAAmB,6CAA6C;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA,mBAAmB,4DAAc;AACjC,gBAAgB,4DAAc;AAC9B;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,iCAAiC,EAAE;AACxD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oCAAoC,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,wBAAwB,EAAE;AAC/C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAA6D,EAAE;AAC/D;AACA;AACA;AACA,SAAS;AACT;AACA,uBAAuB,EAAE;AACzB;AACA,oCAAoC,gDAAgD,EAAE;AACtF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gDAAgD,iCAAiC,EAAE;AACnF;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,wCAAwC,EAAE;AAC1C;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA,+BAA+B,EAAE;AACjC,6DAA6D,+BAA+B,EAAE;AAC9F,+BAA+B,EAAE;AACjC,6DAA6D,6BAA6B,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,iBAAiB,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS,wEAA0B;AACnC;AACA,64BAA64B,sBAAsB,gQAAgQ,63CAA63C,WAAW;AAC3iF;AACA;AACA;AACA,8CAA8C,qBAAqB,kBAAkB,gBAAgB,0BAA0B,iBAAiB,wBAAwB,kBAAkB,qBAAqB,oBAAoB,qBAAqB,sBAAsB,WAAW,8CAA8C,mBAAmB,UAAU,kBAAkB,sBAAsB,cAAc,kBAAkB,UAAU,YAAY,YAAY,8BAA8B,kBAAkB,OAAO,uBAAuB,WAAW,YAAY,gBAAgB,oBAAoB,sBAAsB,kBAAkB,OAAO,aAAa,oBAAoB,WAAW,mBAAmB,uBAAuB,gBAAgB,qBAAqB,8HAA8H,aAAa,gCAAgC,wBAAwB,UAAU,QAAQ,uHAAuH,cAAc,sGAAsG,aAAa,gIAAgI,cAAc,gBAAgB,uLAAuL,aAAa,2OAA2O,cAAc,iDAAiD,gBAAgB,0BAA0B,kBAAkB,WAAW,oBAAoB,yBAAyB,uBAAuB,kBAAkB,OAAO,WAAW,qBAAqB,qBAAqB,UAAU,2DAA2D,iHAAiH,UAAU,oBAAoB,2IAA2I,kCAAkC,kBAAkB,sBAAsB,WAAW,gBAAgB,oFAAoF,UAAU,WAAW,kBAAkB,wBAAwB,6BAA6B,aAAa,4BAA4B,aAAa,WAAW,cAAc,sDAAsD,0BAA0B,4BAA4B,kEAAkE,WAAW,cAAc,kBAAkB,SAAS,WAAW,WAAW,uDAAuD,SAAS,WAAW,0IAA0I,UAAU,eAAe,kDAAkD,kEAAkE,cAAc,yDAAyD,6BAA6B,mBAAmB,sIAAsI,UAAU,oJAAoJ,aAAa,wBAAwB,wKAAwK,kBAAkB,4DAA4D,WAAW,yDAAyD,MAAM,WAAW,oFAAoF,sBAAsB,6BAA6B,kGAAkG,WAAW,4DAA4D,eAAe,wDAAwD,wBAAwB,kBAAkB,oHAAoH,UAAU,2DAA2D,aAAa,kBAAkB,MAAM,OAAO,QAAQ,oBAAoB,gIAAgI,8BAA8B,cAAc,iEAAiE,0BAA0B,wBAAwB,2EAA2E,yBAAyB,uBAAuB,0BAA0B,+DAA+D,0BAA0B,uBAAuB,YAAY,yEAAyE,wBAAwB,wBAAwB,0BAA0B,+DAA+D,wBAAwB,8BAA8B,uBAAuB,wBAAwB,oHAAoH,6BAA6B,iEAAiE,UAAU,yRAAyR,iBAAiB,uDAAuD,yJAAyJ,UAAU,kDAAkD,qKAAqK,UAAU,oHAAoH,UAAU,kDAAkD,0HAA0H,UAAU,qEAAqE,cAAc,0DAA0D,kBAAkB,8DAA8D,WAAW,2DAA2D,SAAS,WAAW,sFAAsF,sBAAsB,6BAA6B,8IAA8I,UAAU,eAAe,kDAAkD,oBAAoB,aAAa,eAAe,mBAAmB,YAAY,UAAU,UAAU,SAAS,WAAW,eAAe,sBAAsB,mBAAmB,mCAAmC,gBAAgB,6DAA6D,aAAa,6OAA6O,YAAY,gBAAgB,UAAU,gCAAgC,sDAAsD,qCAAqC,sDAAsD,8CAA8C,sDAAsD,yCAAyC,sDAAsD,iEAAiE,4BAA4B,gBAAgB,sEAAsE,4BAA4B,gBAAgB,+EAA+E,4BAA4B,gBAAgB,0EAA0E,4BAA4B,gBAAgB,2BAA2B,gBAAgB,cAAc,iDAAiD,YAAY,2BAA2B,cAAc,cAAc;AACliS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,+CAA+C;AAC/C,SAAS,kEAAoB;AAC7B,SAAS,yEAA2B;AACpC,SAAS,gCAAgC,+DAAiB,GAAG,uJAAkD,IAAI;AACnH,SAAS,uFAAqC,+DAAiB,IAAI;AACnE,SAAS,gCAAgC,+DAAiB,GAAG,sGAAwD,IAAI;AACzH,SAAS,wEAAkB;AAC3B,MAAM;AACN;AACA,wBAAwB,4DAAc;AACtC,gCAAgC,4DAAc;AAC9C,uBAAuB,4DAAc;AACrC,wBAAwB,4DAAc;AACtC,0BAA0B,sFAAwC;AAClE,qCAAqC,gGAAkD;AACvF,gCAAgC,2FAA6C;AAC7E,oBAAoB,kFAAoC;AACxD,sBAAsB,iGAAmD;AACzE,+BAA+B,4FAA8C;AAC7E,yBAAyB,sFAAwC;AACjE,4BAA4B,yFAA2C;AACvE,2BAA2B,wFAA0C;AACrE,6BAA6B,0FAA4C;AACzE,6BAA6B,0FAA4C;AACzE;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpzBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;AAC4C;AACiC;AACjE;AACW;AACK;AACH;AACK;AAChC;AACK;;AAEvB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,qBAAqB,EAAE;AAC5C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,sBAAsB,EAAE;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,qBAAqB,EAAE;AAC5C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,sBAAsB,EAAE;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,qBAAqB,EAAE;AAC5C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,sBAAsB,EAAE;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,qBAAqB,EAAE;AAC5C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,sBAAsB,EAAE;AAClD;AACA;AACA,KAAK;AACL;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB,IAAI;AACrB;AACA;AACA;AACA,gCAAgC,4DAAc;AAC9C,gCAAgC,4DAAc;AAC9C,yBAAyB,qFAAuC;AAChE,iCAAiC,4DAAc;AAC/C;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;;AAEjB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sGAAwC,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE,oBAAoB,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,iBAAiB,EAAE;AACxC;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,+BAA+B,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,6GAA+C,EAAE;AAC3E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,mBAAmB,EAAE;AAC1C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uCAAuC,EAAE;AAC9D;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,0BAA0B,6GAA+C,EAAE;AAC3E;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE,2BAA2B,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oCAAoC,EAAE;AAC3D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB,cAAc;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iCAAiC,mHAAsD;AACvF,iBAAiB,IAAI;AACrB;AACA;AACA,2CAA2C;AAC3C,SAAS,kEAAoB;AAC7B,SAAS,wEAAkB;AAC3B,SAAS,+EAAgC,+DAAiB,GAAG,2DAAa,IAAI;AAC9E,SAAS,4EAA6B,+DAAiB,IAAI;AAC3D,SAAS,wFAAyC,+DAAiB,IAAI;AACvE,SAAS,kFAA2B;AACpC,SAAS,gCAAgC,+DAAiB,GAAG,2DAAa,GAAG,gGAAkD,IAAI;AACnI,SAAS,iFAAyB;AAClC,SAAS,8DAAgB;AACzB,MAAM;AACN;AACA,sBAAsB,4DAAc;AACpC,gBAAgB,4DAAc;AAC9B,yBAAyB,4DAAc;AACvC,sBAAsB,4DAAc;AACpC,kBAAkB,4DAAc;AAChC,+BAA+B,4DAAc;AAC7C,mBAAmB,4DAAc;AACjC,sBAAsB,4DAAc;AACpC;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjqBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;AACG;AACS;AACI;AACuK;AAC/K;AACwF;AACpF;AACT;;AAEvB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,+FAAyC,sBAAsB,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,mBAAmB,EAAE;AAC1C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oBAAoB,EAAE;AAC3C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,2DAA2D,EAAE;AAC7D;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mDAAmD,8BAA8B,EAAE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,gDAAgD;AAChD,SAAS,yEAA2B;AACpC,MAAM;AACN;AACA,oBAAoB,6DAAe;AACnC,qBAAqB,2JAAuD,uBAAuB,EAAE,IAAI,oBAAoB,IAAI;AACjI,kBAAkB,4DAAc;AAChC,2BAA2B,4DAAc;AACzC,mBAAmB,4DAAc;AACjC,sBAAsB,4DAAc;AACpC,sBAAsB,4DAAc;AACpC,sBAAsB,4DAAc;AACpC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,sBAAsB,EAAE;AAC7C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oBAAoB,EAAE;AAC3C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,+CAA+C,EAAE;AACtE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,+CAA+C,+CAA+C,EAAE;AAChG;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wEAA0B;AACnC,2ZAA2Z,mBAAmB,iiBAAiiB;AAC/8B,gDAAgD,qBAAqB,iBAAiB,eAAe,oBAAoB,mBAAmB,mBAAmB,sBAAsB,qBAAqB,sBAAsB,qBAAqB,kBAAkB,WAAW,YAAY,cAAc,wBAAwB,sBAAsB,YAAY,OAAO,kBAAkB,MAAM,mCAAmC,WAAW,iBAAiB,mBAAmB,kBAAkB,iDAAiD,gBAAgB,wBAAwB,kBAAkB,sBAAsB,YAAY,OAAO,kBAAkB,MAAM,4DAA4D,WAAW,sBAAsB,iDAAiD,gBAAgB,2CAA2C,oBAAoB,6CAA6C,2CAA2C,mBAAmB,yBAAyB,qBAAqB,QAAQ,oBAAoB,iBAAiB,gBAAgB,mCAAmC,kBAAkB,eAAe,gDAAgD,SAAS,eAAe,kBAAkB,0DAA0D,gBAAgB,iBAAiB,yDAAyD,eAAe,kBAAkB,kBAAkB,sBAAsB,qBAAqB,YAAY,WAAW,UAAU,oBAAoB;AAC7gD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,iDAAiD;AACjD,SAAS,oCAAoC,+DAAiB,IAAI;AAClE,SAAS,kEAAoB;AAC7B,SAAS,yEAA2B;AACpC,SAAS,wEAAsB;AAC/B,SAAS,4FAAmC;AAC5C,SAAS,gCAAgC,+DAAiB,GAAG,kKAA+C,IAAI;AAChH,MAAM;AACN;AACA,gBAAgB,4DAAc;AAC9B,kBAAkB,4DAAc;AAChC,uBAAuB,mFAAqC;AAC5D,4BAA4B,wFAA0C;AACtE,6BAA6B,yFAA2C;AACxE,qBAAqB,4DAAc;AACnC,mBAAmB,4DAAc;AACjC,2BAA2B,4DAAc;AACzC,sBAAsB,4DAAc;AACpC,sBAAsB,4DAAc;AACpC,oBAAoB,6DAAe;AACnC,qBAAqB,2IAAsC;AAC3D,2BAA2B,kFAAoC;AAC/D;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACp2BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACiF;AAC7D;AACiB;AACZ;AACO;AACP;AACwD;AACZ;AAC4L;AACjN;AAC+L;AAC/K;AAChC;AAC6B;AACtC;;AAEvB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yKAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wJAAgC,aAAa;AAC7C;AACA,+EAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,eAAe,EAAE;;AAEjB;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAgF,iCAAiC,EAAE;AACnH;AACA;AACA;AACA,sKAAsD,qCAAqC,EAAE;AAC7F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAA2E,UAAU,EAAE,4EAAoB,EAAE;AAC7G;AACA;AACA;AACA,mIAA2E,WAAW,EAAE,4EAAoB,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,0BAA0B,EAAE;AACjD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,uBAAuB,EAAE;AAC9C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,qCAAqC,EAAE;AAC5D;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,0BAA0B,EAAE;AACjD;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,oBAAoB,EAAE;AAC3C;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB;AACpB;AACA,qBAAqB,iBAAiB,EAAE;AACxC;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE,2EAA2E,yBAAyB,EAAE;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA,mDAAmD,sDAAsD,EAAE;AAC3G;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB,EAAE;AAClB;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,8BAA8B,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,0LAA0E,0BAA0B,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sGAAgE,6BAA6B,EAAE;AAC/F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,sCAAsC,EAAE,4CAA4C,qBAAqB,EAAE;AAC3G;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,8DAA8D,kBAAkB,EAAE;AAClF;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE,uDAAuD,EAAE;AAClF;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B,2BAA2B,EAAE;AAC7B;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,SAAS,wEAA0B;AACnC;AACA,yRAAyR,yBAAyB,8HAA8H,cAAc,4uBAA4uB,oBAAoB;AAC9rC,0CAA0C,qBAAqB,WAAW,UAAU,oBAAoB,qBAAqB,eAAe,kBAAkB,sBAAsB,yCAAyC,yBAAyB,sBAAsB,qBAAqB,iBAAiB,eAAe,kBAAkB,mBAAmB,YAAY,WAAW,gBAAgB,uBAAuB,mBAAmB,uBAAuB,mBAAmB,gBAAgB,uBAAuB,0BAA0B,mBAAmB,sBAAsB,wHAAwH,2BAA2B,6DAA6D,2BAA2B,kBAAkB,QAAQ,SAAS,kCAAkC,mCAAmC,qBAAqB,aAAa,kBAAkB,gBAAgB,gBAAgB,cAAc,iCAAiC,cAAc,iBAAiB,iBAAiB,eAAe,gDAAgD,uGAAuG,6CAA6C,kBAAkB,mBAAmB,oEAAoE,kBAAkB,gBAAgB,WAAW,mFAAmF,eAAe,sDAAsD,wBAAwB,wBAAwB,sDAAsD,yDAAyD,kBAAkB,gBAAgB,cAAc;AACjyD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB,qHAAuD;AAChF,yBAAyB;AACzB;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,4CAA4C;AAC5C,SAAS,4EAAuB;AAChC,SAAS,yEAA2B;AACpC,SAAS,8DAAgB;AACzB,SAAS,mFAA2B;AACpC,SAAS,kEAAoB;AAC7B,SAAS,uFAAqC,+DAAiB,IAAI;AACnE,SAAS,4EAA6B,+DAAiB,IAAI;AAC3D,SAAS,wFAAyC,+DAAiB,IAAI;AACvE,SAAS,iGAAmC,+DAAiB,IAAI;AACjE,SAAS,+EAAgC,2DAAa,GAAG,+DAAiB,IAAI;AAC9E,SAAS,gCAAgC,qFAAuC,IAAI;AACpF,SAAS,gCAAgC,kGAAoD,IAAI;AACjG,MAAM;AACN;AACA,qBAAqB,oFAAsC;AAC3D,mBAAmB,kFAAoC;AACvD,wBAAwB,mJAAgD;AACxE,qBAAqB,iJAA2C,oBAAoB,IAAI;AACxF,0BAA0B,oJAA8C;AACxE,wBAAwB,4DAAc;AACtC,2BAA2B,8FAAgD;AAC3E,yBAAyB,4DAAc;AACvC,sBAAsB,4DAAc;AACpC,sBAAsB,4DAAc;AACpC,oCAAoC,4DAAc;AAClD,yBAAyB,4DAAc;AACvC,mBAAmB,4DAAc;AACjC,uBAAuB,mFAAqC;AAC5D,4BAA4B,wFAA0C;AACtE,+BAA+B,4DAAc;AAC7C,gBAAgB,4DAAc;AAC9B,0BAA0B,6DAAe;AACzC,2BAA2B,gFAAkC;AAC7D,2BAA2B,gFAAkC;AAC7D,6BAA6B,6DAAe;AAC5C,yBAAyB,6DAAe;AACxC;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,CAAC;;AAED;AACA;AACA,cAAc,WAAW;AACzB;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEQ;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kGC9wDmK,yJAAkE,8DAAiC;kGAA0e,wHAAoC,8DAAqC,IAAa,qMAAwB;iGAAe,0DAAoD;kGAAa,qNAAgK,oFAAO;kGAAtsB,keAAiW,4dAAoC,IAAyF,wdAAoD,IAAa,qYAAgK,iDAAvX,mBAAwB,cAAhW,YAAiW,EAAzB,SAAwB,GAAe,qBAAqB,EAAnC,YAAoC,EAAtB,SAAqB,GAAyH,oBAAoB,EAAnD,YAAoD,EAArB,SAAoB,GAAuG,2EAAsE,qBAA/J,YAAgK,EAAvE,SAAsE,mDAA1pB,mBAAwB,cAAC,mBAA8B,cAAC,2CAAyD,sBAAC,2CAAoE,sBAAC,sCAAsC,GAAC,oCAAkC,GAApS,YAAiW,EAA7T,SAAwB,EAAC,SAA8B,EAAC,SAAyD,EAAC,SAAoE,EAAC,SAAsC,EAAC,SAAkC;kGAA8b,yJAAkE,8DAAiC;kGAAyB,kLAAiF,2MAA8G,wDAA1E,sCAAsC,GAAC,oCAAkC,GAA7G,YAA8G,EAA1E,SAAsC,EAAC,SAAkC;kGAAc,wHAA8C,+JAAoC,qLAA8E,KAAM,8KAA4E,KAAM,8JAAwC,KAAY,uLAAiE,qLAA8E,KAAM,8KAA4E,KAAM,8JAAwC,wDAA/b,mBAAmC,mBAA7E,YAA8E,EAApC,SAAmC,GAA+C,mBAAmC,mBAA3E,YAA4E,EAApC,SAAmC,GAAsK,mBAAmC,mBAA7E,YAA8E,EAApC,SAAmC,GAA+C,mBAAmC,mBAA3E,YAA4E,EAApC,SAAmC;kGAA6J,mJAA8E,8DAA+B,uDAAhF,mBAAgD,2BAA7E,YAA8E,EAAjD,SAAgD;mGAAoK,sJAA4D,gFAAa,yDAAlD,mBAAmB,eAA1C,YAA4D,EAArC,SAAmB,GAAkB,sDAAa;mGAA1L,2LAAiH,2YAA4D,GAAmB,0DAAiD,IAAa,8JAAwC,IAAM,0DAA2C,iDAAjO,mBAAiB,YAAtB,YAA4D,EAAvD,SAAiB,mDAAvE,mBAAgD,2BAAhH,YAAiH,EAAjD,SAAgD;ycAAl1E,2JAAoC,gPAA+H,YAAzE;;wBAAwE;MAA9H,wBAA+H,0YAAkE,IAAoD,mLAAkD,8DAAY,IAAa,kKAA2C,2YAAiW,IAAiY,sYAAkE,IAA0D,sYAAiF,IAA2H,sYAA8C,IAAwiB,iVAAmF,6dAA8E,IAAkD,0dAAiH,iDAA7oE,mBAA8B,yBAAjE,YAAkE,EAA/B,SAA8B,GAAud,mBAA2B,sBAAvU,aAAiW,EAArD,SAA2B,GAA8b,mBAA8B,yBAAjE,aAAkE,EAA/B,SAA8B,GAA4G,4CAA+B,GAAhF,aAAiF,EAAhC,SAA+B,GAA0I,4CAA+B,GAA7C,aAA8C,EAAhC,SAA+B,GAAulB,mBAAoC,0BAAlF,aAAmF,EAArC,SAAoC,GAAM,uBAAuB,EAA5B,aAA8E,EAAzE,SAAuB,GAA6I,sBAAsB,EAA/D,aAAiH,EAAxE,SAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+FCAnnE,2JAA0D,+MAA2B;+FAA+F,wHAAuB,kMAAgB;8FAAO,0DAA6D;+FAAlM,qUAAuF,0bAAuB,IAAuB,qdAA6D,iDAAxI,qBAA4B,gBAAtF,YAAuF,EAA7B,SAA4B,GAAuF,oBAAoB,EAA5D,YAA6D,EAArB,SAAoB;+FAAsmB,2VAA6W,YAA5N;;wBAAuC;MAAkJ;;wBAAkC;MAA5W,qcAA6W,mPAAqG,YAAxC;;wBAAuC;MAApG,wBAAqG,8DAAY,iDAAld,iIAA+C,GAAC,mBAAsB,aAAlF,YAA6W,EAAjW,SAA+C,EAAC,SAAsB,mDAAC,8DAA6D,GAAyC,mBAA0C,mBAAC,mBAA6D,sBAAC,mBAAuC,mBAAzU,YAA6W,EAA1R,SAA6D,EAAyC,SAA0C,EAAC,SAA6D,EAAC,SAAuC,GAAoE,yBAA4B,EAA5D,YAAqG,EAArE,SAA4B;sVAA39C,mRAA6H,YAAvD;;wBAAkB;MAAxF,0PAA6H,mUAAiD,ydAA0D,IAAmC,sdAAuF,IAAqI,6JAAsC,0JAA8B,KAAkB,2IAAqf,YAAtE;;wBAAyB;MAAC;;wBAAwB;MAAC;;wBAAkB;MAApf,s0BAAqf,mDAAv5B,mBAAkB,QAAhD,YAAiD,EAAnB,SAAkB,GAAsC,oBAAoB,EAAzD,YAA0D,EAArB,SAAoB,GAAwE,qBAAqB,EAAzD,aAAuF,EAAnD,SAAqB,GAAqd,wEAAoC,GAAuC,mBAA2C,aAAqD,mBAAuC,WAA3F,wDAAmD,sBAApS,kDAAmE,EAAC,mBAAqD,kBAAsC,mBAAqC,YAAnO,mBAA8B,EAA9D,mBAA+B,EAAlE,aAAqf,EAAzR,SAAoC,EAAuC,SAA2C,EAAqD,SAAuC,EAA3F,SAAmD,EAApS,SAAmE,EAAC,SAAqD,EAAsC,SAAqC,EAAnO,UAA8B,EAA9D,UAA+B",
  "file": "dashboard-example-dashboard-example-module-ngfactory~reactive-forms-reactive-forms-examples-module-n~06ef8c25.js",
  "sourcesContent": [
    "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Platform, supportsPassiveEventListeners, PlatformModule } from '@angular/cdk/platform';\nimport { Directive, ElementRef, EventEmitter, Injectable, NgZone, Output, Input, NgModule, defineInjectable, inject } from '@angular/core';\nimport { EMPTY, Subject, fromEvent } from 'rxjs';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { auditTime, takeUntil } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Options to pass to the animationstart listener.\n */\nvar /** @type {?} */ listenerOptions = supportsPassiveEventListeners() ? { passive: true } : false;\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/\\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nvar AutofillMonitor = /** @class */ (function () {\n    function AutofillMonitor(_platform, _ngZone) {\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._monitoredElements = new Map();\n    }\n    /**\n     * Monitor for changes in the autofill state of the given input element.\n     * @param element The element to monitor.\n     * @return A stream of autofill state changes.\n     */\n    /**\n     * Monitor for changes in the autofill state of the given input element.\n     * @param {?} element The element to monitor.\n     * @return {?} A stream of autofill state changes.\n     */\n    AutofillMonitor.prototype.monitor = /**\n     * Monitor for changes in the autofill state of the given input element.\n     * @param {?} element The element to monitor.\n     * @return {?} A stream of autofill state changes.\n     */\n    function (element) {\n        if (!this._platform.isBrowser) {\n            return EMPTY;\n        }\n        var /** @type {?} */ info = this._monitoredElements.get(element);\n        if (info) {\n            return info.subject.asObservable();\n        }\n        var /** @type {?} */ result = new Subject();\n        var /** @type {?} */ listener = function (event) {\n            if (event.animationName === 'cdk-text-field-autofill-start') {\n                element.classList.add('cdk-text-field-autofilled');\n                result.next({ target: /** @type {?} */ (event.target), isAutofilled: true });\n            }\n            else if (event.animationName === 'cdk-text-field-autofill-end') {\n                element.classList.remove('cdk-text-field-autofilled');\n                result.next({ target: /** @type {?} */ (event.target), isAutofilled: false });\n            }\n        };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('animationstart', listener, listenerOptions);\n            element.classList.add('cdk-text-field-autofill-monitored');\n        });\n        this._monitoredElements.set(element, {\n            subject: result,\n            unlisten: function () {\n                element.removeEventListener('animationstart', listener, listenerOptions);\n            }\n        });\n        return result.asObservable();\n    };\n    /**\n     * Stop monitoring the autofill state of the given input element.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stop monitoring the autofill state of the given input element.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    AutofillMonitor.prototype.stopMonitoring = /**\n     * Stop monitoring the autofill state of the given input element.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ info = this._monitoredElements.get(element);\n        if (info) {\n            info.unlisten();\n            info.subject.complete();\n            element.classList.remove('cdk-text-field-autofill-monitored');\n            element.classList.remove('cdk-text-field-autofilled');\n            this._monitoredElements.delete(element);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    AutofillMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._monitoredElements.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    AutofillMonitor.decorators = [\n        { type: Injectable, args: [{ providedIn: 'root' },] },\n    ];\n    /** @nocollapse */\n    AutofillMonitor.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    /** @nocollapse */ AutofillMonitor.ngInjectableDef = defineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(inject(Platform), inject(NgZone)); }, token: AutofillMonitor, providedIn: \"root\" });\n    return AutofillMonitor;\n}());\n/**\n * A directive that can be used to monitor the autofill state of an input.\n */\nvar CdkAutofill = /** @class */ (function () {\n    function CdkAutofill(_elementRef, _autofillMonitor) {\n        this._elementRef = _elementRef;\n        this._autofillMonitor = _autofillMonitor;\n        /**\n         * Emits when the autofill state of the element changes.\n         */\n        this.cdkAutofill = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    CdkAutofill.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._autofillMonitor\n            .monitor(this._elementRef.nativeElement)\n            .subscribe(function (event) { return _this.cdkAutofill.emit(event); });\n    };\n    /**\n     * @return {?}\n     */\n    CdkAutofill.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    };\n    CdkAutofill.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkAutofill]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkAutofill.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: AutofillMonitor, },\n    ]; };\n    CdkAutofill.propDecorators = {\n        \"cdkAutofill\": [{ type: Output },],\n    };\n    return CdkAutofill;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n */\nvar CdkTextareaAutosize = /** @class */ (function () {\n    function CdkTextareaAutosize(_elementRef, _platform, _ngZone) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._destroyed = new Subject();\n        this._enabled = true;\n        this._textareaElement = /** @type {?} */ (this._elementRef.nativeElement);\n    }\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"minRows\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this._minRows; },\n        set: /**\n         * Minimum amount of rows in the textarea.\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._minRows = value;\n            this._setMinHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"maxRows\", {\n        get: /**\n         * Maximum amount of rows in the textarea.\n         * @return {?}\n         */\n        function () { return this._maxRows; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._maxRows = value;\n            this._setMaxHeight();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTextareaAutosize.prototype, \"enabled\", {\n        get: /**\n         * Whether autosizing is enabled or not\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            value = coerceBooleanProperty(value);\n            // Only act if the actual value changed. This specifically helps to not run\n            // resizeToFitContent too early (i.e. before ngAfterViewInit)\n            if (this._enabled !== value) {\n                (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setMinHeight = /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ minHeight = this.minRows && this._cachedLineHeight ?\n            this.minRows * this._cachedLineHeight + \"px\" : null;\n        if (minHeight) {\n            this._setTextareaStyle('minHeight', minHeight);\n        }\n    };\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setMaxHeight = /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ maxHeight = this.maxRows && this._cachedLineHeight ?\n            this.maxRows * this._cachedLineHeight + \"px\" : null;\n        if (maxHeight) {\n            this._setTextareaStyle('maxHeight', maxHeight);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._platform.isBrowser) {\n            // Remember the height which we started with in case autosizing is disabled\n            this._initialHeight = this._textareaElement.style.height;\n            this.resizeToFitContent();\n            this._ngZone.runOutsideAngular(function () {\n                fromEvent(window, 'resize')\n                    .pipe(auditTime(16), takeUntil(_this._destroyed))\n                    .subscribe(function () { return _this.resizeToFitContent(true); });\n            });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyed.next();\n        this._destroyed.complete();\n    };\n    /**\n     * Sets a style property on the textarea element.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._setTextareaStyle = /**\n     * Sets a style property on the textarea element.\n     * @param {?} property\n     * @param {?} value\n     * @return {?}\n     */\n    function (property, value) {\n        this._textareaElement.style[property] = value;\n    };\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._cacheTextareaLineHeight = /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @return {?}\n     */\n    function () {\n        if (this._cachedLineHeight) {\n            return;\n        }\n        // Use a clone element because we have to override some styles.\n        var /** @type {?} */ textareaClone = /** @type {?} */ (this._textareaElement.cloneNode(false));\n        textareaClone.rows = 1;\n        // Use `position: absolute` so that this doesn't cause a browser layout and use\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n        // would affect the height.\n        textareaClone.style.position = 'absolute';\n        textareaClone.style.visibility = 'hidden';\n        textareaClone.style.border = 'none';\n        textareaClone.style.padding = '0';\n        textareaClone.style.height = '';\n        textareaClone.style.minHeight = '';\n        textareaClone.style.maxHeight = '';\n        // In Firefox it happens that textarea elements are always bigger than the specified amount\n        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n        // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n        // to hidden. This ensures that there is no invalid calculation of the line height.\n        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n        textareaClone.style.overflow = 'hidden'; /** @type {?} */\n        ((this._textareaElement.parentNode)).appendChild(textareaClone);\n        this._cachedLineHeight = textareaClone.clientHeight; /** @type {?} */\n        ((this._textareaElement.parentNode)).removeChild(textareaClone);\n        // Min and max heights have to be re-calculated if the cached line height changes\n        this._setMinHeight();\n        this._setMaxHeight();\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        if (this._platform.isBrowser) {\n            this.resizeToFitContent();\n        }\n    };\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.resizeToFitContent = /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n    function (force) {\n        var _this = this;\n        if (force === void 0) { force = false; }\n        // If autosizing is disabled, just skip everything else\n        if (!this._enabled) {\n            return;\n        }\n        this._cacheTextareaLineHeight();\n        // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n        // in checking the height of the textarea.\n        if (!this._cachedLineHeight) {\n            return;\n        }\n        var /** @type {?} */ textarea = /** @type {?} */ (this._elementRef.nativeElement);\n        var /** @type {?} */ value = textarea.value;\n        // Only resize of the value changed since these calculations can be expensive.\n        if (value === this._previousValue && !force) {\n            return;\n        }\n        var /** @type {?} */ placeholderText = textarea.placeholder;\n        // Reset the textarea height to auto in order to shrink back to its default size.\n        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n        // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n        // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n        // need to be removed temporarily.\n        textarea.classList.add('cdk-textarea-autosize-measuring');\n        textarea.placeholder = '';\n        // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with\n        // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n        var /** @type {?} */ height = textarea.scrollHeight - 4;\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n        textarea.style.height = height + \"px\";\n        textarea.classList.remove('cdk-textarea-autosize-measuring');\n        textarea.placeholder = placeholderText;\n        // On Firefox resizing the textarea will prevent it from scrolling to the caret position.\n        // We need to re-set the selection in order for it to scroll to the proper position.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                return requestAnimationFrame(function () {\n                    var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;\n                    // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n                    // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n                    // between the time we requested the animation frame and when it was executed.\n                    if (!_this._destroyed.isStopped) {\n                        textarea.setSelectionRange(selectionStart, selectionEnd);\n                    }\n                });\n            });\n        }\n        this._previousValue = value;\n    };\n    /**\n     * Resets the textarea to it's original size\n     */\n    /**\n     * Resets the textarea to it's original size\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype.reset = /**\n     * Resets the textarea to it's original size\n     * @return {?}\n     */\n    function () {\n        // Do not try to change the textarea, if the initialHeight has not been determined yet\n        // This might potentially remove styles when reset() is called before ngAfterViewInit\n        if (this._initialHeight === undefined) {\n            return;\n        }\n        this._textareaElement.style.height = this._initialHeight;\n    };\n    /**\n     * @return {?}\n     */\n    CdkTextareaAutosize.prototype._noopInputHandler = /**\n     * @return {?}\n     */\n    function () {\n        // no-op handler that ensures we're running change detection on input events.\n    };\n    CdkTextareaAutosize.decorators = [\n        { type: Directive, args: [{\n                    selector: 'textarea[cdkTextareaAutosize]',\n                    exportAs: 'cdkTextareaAutosize',\n                    host: {\n                        'class': 'cdk-textarea-autosize',\n                        // Textarea elements that have the directive applied should have a single row by default.\n                        // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                        'rows': '1',\n                        '(input)': '_noopInputHandler()',\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTextareaAutosize.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    CdkTextareaAutosize.propDecorators = {\n        \"minRows\": [{ type: Input, args: ['cdkAutosizeMinRows',] },],\n        \"maxRows\": [{ type: Input, args: ['cdkAutosizeMaxRows',] },],\n        \"enabled\": [{ type: Input, args: ['cdkTextareaAutosize',] },],\n    };\n    return CdkTextareaAutosize;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar TextFieldModule = /** @class */ (function () {\n    function TextFieldModule() {\n    }\n    TextFieldModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [CdkAutofill, CdkTextareaAutosize],\n                    imports: [PlatformModule],\n                    exports: [CdkAutofill, CdkTextareaAutosize],\n                },] },\n    ];\n    return TextFieldModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n//# sourceMappingURL=text-field.es5.js.map\n",
    "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { BACKSPACE, DELETE, SPACE, ENTER } from '@angular/cdk/keycodes';\nimport { Platform } from '@angular/cdk/platform';\nimport { ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, NgZone, Optional, Output, InjectionToken, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Self, ViewEncapsulation, NgModule } from '@angular/core';\nimport { MAT_RIPPLE_GLOBAL_OPTIONS, mixinColor, mixinDisabled, mixinDisableRipple, RippleRenderer, ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\nimport { Subject, merge, Subscription } from 'rxjs';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { startWith } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Event object emitted by MatChip when selected or deselected.\n */\nvar  /**\n * Event object emitted by MatChip when selected or deselected.\n */\nMatChipSelectionChange = /** @class */ (function () {\n    function MatChipSelectionChange(source, selected, isUserInput) {\n        if (isUserInput === void 0) { isUserInput = false; }\n        this.source = source;\n        this.selected = selected;\n        this.isUserInput = isUserInput;\n    }\n    return MatChipSelectionChange;\n}());\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatChipBase = /** @class */ (function () {\n    function MatChipBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatChipBase;\n}());\nvar /** @type {?} */ _MatChipMixinBase = mixinColor(mixinDisableRipple(mixinDisabled(MatChipBase)), 'primary');\nvar /** @type {?} */ CHIP_ATTRIBUTE_NAMES = ['mat-basic-chip'];\n/**\n * Dummy directive to add CSS class to chip avatar.\n * \\@docs-private\n */\nvar MatChipAvatar = /** @class */ (function () {\n    function MatChipAvatar() {\n    }\n    MatChipAvatar.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-chip-avatar, [matChipAvatar]',\n                    host: { 'class': 'mat-chip-avatar' }\n                },] },\n    ];\n    return MatChipAvatar;\n}());\n/**\n * Dummy directive to add CSS class to chip trailing icon.\n * \\@docs-private\n */\nvar MatChipTrailingIcon = /** @class */ (function () {\n    function MatChipTrailingIcon() {\n    }\n    MatChipTrailingIcon.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',\n                    host: { 'class': 'mat-chip-trailing-icon' }\n                },] },\n    ];\n    return MatChipTrailingIcon;\n}());\n/**\n * Material design styled Chip component. Used inside the MatChipList component.\n */\nvar MatChip = /** @class */ (function (_super) {\n    __extends(MatChip, _super);\n    function MatChip(_elementRef, ngZone, platform, globalOptions) {\n        var _this = _super.call(this, _elementRef) || this;\n        _this._elementRef = _elementRef;\n        /**\n         * Ripple configuration for ripples that are launched on pointer down.\n         * \\@docs-private\n         */\n        _this.rippleConfig = {};\n        /**\n         * Whether the chip has focus.\n         */\n        _this._hasFocus = false;\n        /**\n         * Whether the chip list is selectable\n         */\n        _this.chipListSelectable = true;\n        _this._selected = false;\n        _this._selectable = true;\n        _this._removable = true;\n        /**\n         * Emits when the chip is focused.\n         */\n        _this._onFocus = new Subject();\n        /**\n         * Emits when the chip is blured.\n         */\n        _this._onBlur = new Subject();\n        /**\n         * Emitted when the chip is selected or deselected.\n         */\n        _this.selectionChange = new EventEmitter();\n        /**\n         * Emitted when the chip is destroyed.\n         */\n        _this.destroyed = new EventEmitter();\n        /**\n         * Emitted when a chip is to be removed.\n         */\n        _this.removed = new EventEmitter();\n        _this._addHostClassName();\n        _this._chipRipple = new RippleRenderer(_this, ngZone, _elementRef, platform);\n        _this._chipRipple.setupTriggerEvents(_elementRef.nativeElement);\n        if (globalOptions) {\n            _this.rippleConfig = {\n                speedFactor: globalOptions.baseSpeedFactor,\n                animation: globalOptions.animation,\n                terminateOnPointerUp: globalOptions.terminateOnPointerUp,\n            };\n        }\n        return _this;\n    }\n    Object.defineProperty(MatChip.prototype, \"rippleDisabled\", {\n        /**\n         * Whether ripples are disabled on interaction\n         * @docs-private\n         */\n        get: /**\n         * Whether ripples are disabled on interaction\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this.disabled || this.disableRipple;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"selected\", {\n        get: /**\n         * Whether the chip is selected.\n         * @return {?}\n         */\n        function () { return this._selected; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._selected = coerceBooleanProperty(value);\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: false,\n                selected: value\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"value\", {\n        get: /**\n         * The value of the chip. Defaults to the content inside `<mat-chip>` tags.\n         * @return {?}\n         */\n        function () {\n            return this._value != undefined\n                ? this._value\n                : this._elementRef.nativeElement.textContent;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._value = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"selectable\", {\n        get: /**\n         * Whether or not the chip is selectable. When a chip is not selectable,\n         * changes to it's selected state are always ignored. By default a chip is\n         * selectable, and it becomes non-selectable if it's parent chip list is\n         * not selectable.\n         * @return {?}\n         */\n        function () { return this._selectable && this.chipListSelectable; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._selectable = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"removable\", {\n        get: /**\n         * Determines whether or not the chip displays the remove styling and emits (removed) events.\n         * @return {?}\n         */\n        function () { return this._removable; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._removable = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"ariaSelected\", {\n        /** The ARIA selected applied to the chip. */\n        get: /**\n         * The ARIA selected applied to the chip.\n         * @return {?}\n         */\n        function () {\n            return this.selectable ? this.selected.toString() : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatChip.prototype._addHostClassName = /**\n     * @return {?}\n     */\n    function () {\n        // Add class for the different chips\n        for (var _i = 0, CHIP_ATTRIBUTE_NAMES_1 = CHIP_ATTRIBUTE_NAMES; _i < CHIP_ATTRIBUTE_NAMES_1.length; _i++) {\n            var attr = CHIP_ATTRIBUTE_NAMES_1[_i];\n            if (this._elementRef.nativeElement.hasAttribute(attr) ||\n                this._elementRef.nativeElement.tagName.toLowerCase() === attr) {\n                (/** @type {?} */ (this._elementRef.nativeElement)).classList.add(attr);\n                return;\n            }\n        }\n        (/** @type {?} */ (this._elementRef.nativeElement)).classList.add('mat-standard-chip');\n    };\n    /**\n     * @return {?}\n     */\n    MatChip.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.destroyed.emit({ chip: this });\n        this._chipRipple._removeTriggerEvents();\n    };\n    /** Selects the chip. */\n    /**\n     * Selects the chip.\n     * @return {?}\n     */\n    MatChip.prototype.select = /**\n     * Selects the chip.\n     * @return {?}\n     */\n    function () {\n        this._selected = true;\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: false,\n            selected: true\n        });\n    };\n    /** Deselects the chip. */\n    /**\n     * Deselects the chip.\n     * @return {?}\n     */\n    MatChip.prototype.deselect = /**\n     * Deselects the chip.\n     * @return {?}\n     */\n    function () {\n        this._selected = false;\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: false,\n            selected: false\n        });\n    };\n    /** Select this chip and emit selected event */\n    /**\n     * Select this chip and emit selected event\n     * @return {?}\n     */\n    MatChip.prototype.selectViaInteraction = /**\n     * Select this chip and emit selected event\n     * @return {?}\n     */\n    function () {\n        this._selected = true;\n        // Emit select event when selected changes.\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: true,\n            selected: true\n        });\n    };\n    /** Toggles the current selected state of this chip. */\n    /**\n     * Toggles the current selected state of this chip.\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MatChip.prototype.toggleSelected = /**\n     * Toggles the current selected state of this chip.\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    function (isUserInput) {\n        if (isUserInput === void 0) { isUserInput = false; }\n        this._selected = !this.selected;\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: isUserInput,\n            selected: this._selected\n        });\n        return this.selected;\n    };\n    /** Allows for programmatic focusing of the chip. */\n    /**\n     * Allows for programmatic focusing of the chip.\n     * @return {?}\n     */\n    MatChip.prototype.focus = /**\n     * Allows for programmatic focusing of the chip.\n     * @return {?}\n     */\n    function () {\n        if (!this._hasFocus) {\n            this._elementRef.nativeElement.focus();\n            this._onFocus.next({ chip: this });\n        }\n        this._hasFocus = true;\n    };\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     */\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     * @return {?}\n     */\n    MatChip.prototype.remove = /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this.removable) {\n            this.removed.emit({ chip: this });\n        }\n    };\n    /** Ensures events fire properly upon click. */\n    /**\n     * Ensures events fire properly upon click.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChip.prototype._handleClick = /**\n     * Ensures events fire properly upon click.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check disabled\n        if (this.disabled) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    /** Handle custom key presses. */\n    /**\n     * Handle custom key presses.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChip.prototype._handleKeydown = /**\n     * Handle custom key presses.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (this.disabled) {\n            return;\n        }\n        switch (event.keyCode) {\n            case DELETE:\n            case BACKSPACE:\n                // If we are removable, remove the focused chip\n                this.remove();\n                // Always prevent so page navigation does not occur\n                event.preventDefault();\n                break;\n            case SPACE:\n                // If we are selectable, toggle the focused chip\n                if (this.selectable) {\n                    this.toggleSelected(true);\n                }\n                // Always prevent space from scrolling the page since the list has focus\n                event.preventDefault();\n                break;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatChip.prototype._blur = /**\n     * @return {?}\n     */\n    function () {\n        this._hasFocus = false;\n        this._onBlur.next({ chip: this });\n    };\n    MatChip.decorators = [\n        { type: Directive, args: [{\n                    selector: \"mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\",\n                    inputs: ['color', 'disabled', 'disableRipple'],\n                    exportAs: 'matChip',\n                    host: {\n                        'class': 'mat-chip',\n                        '[attr.tabindex]': 'disabled ? null : -1',\n                        'role': 'option',\n                        '[class.mat-chip-selected]': 'selected',\n                        '[class.mat-chip-with-avatar]': 'avatar',\n                        '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',\n                        '[class.mat-chip-disabled]': 'disabled',\n                        '[attr.disabled]': 'disabled || null',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.aria-selected]': 'ariaSelected',\n                        '(click)': '_handleClick($event)',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(focus)': 'focus()',\n                        '(blur)': '_blur()',\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    MatChip.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: NgZone, },\n        { type: Platform, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] },] },\n    ]; };\n    MatChip.propDecorators = {\n        \"avatar\": [{ type: ContentChild, args: [MatChipAvatar,] },],\n        \"trailingIcon\": [{ type: ContentChild, args: [MatChipTrailingIcon,] },],\n        \"removeIcon\": [{ type: ContentChild, args: [forwardRef(function () { return MatChipRemove; }),] },],\n        \"selected\": [{ type: Input },],\n        \"value\": [{ type: Input },],\n        \"selectable\": [{ type: Input },],\n        \"removable\": [{ type: Input },],\n        \"selectionChange\": [{ type: Output },],\n        \"destroyed\": [{ type: Output },],\n        \"removed\": [{ type: Output },],\n    };\n    return MatChip;\n}(_MatChipMixinBase));\n/**\n * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n *     `<mat-chip>\n *       <mat-icon matChipRemove>cancel</mat-icon>\n *     </mat-chip>`\n *\n * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n * styles to properly center the icon within the chip.\n */\nvar MatChipRemove = /** @class */ (function () {\n    function MatChipRemove(_parentChip) {\n        this._parentChip = _parentChip;\n    }\n    /** Calls the parent chip's public `remove()` method if applicable. */\n    /**\n     * Calls the parent chip's public `remove()` method if applicable.\n     * @return {?}\n     */\n    MatChipRemove.prototype._handleClick = /**\n     * Calls the parent chip's public `remove()` method if applicable.\n     * @return {?}\n     */\n    function () {\n        if (this._parentChip.removable) {\n            this._parentChip.remove();\n        }\n    };\n    MatChipRemove.decorators = [\n        { type: Directive, args: [{\n                    selector: '[matChipRemove]',\n                    host: {\n                        'class': 'mat-chip-remove mat-chip-trailing-icon',\n                        '(click)': '_handleClick()',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    MatChipRemove.ctorParameters = function () { return [\n        { type: MatChip, },\n    ]; };\n    return MatChipRemove;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token to be used to override the default options for the chips module.\n */\nvar /** @type {?} */ MAT_CHIPS_DEFAULT_OPTIONS = new InjectionToken('mat-chips-default-options');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatChipListBase = /** @class */ (function () {\n    function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n    return MatChipListBase;\n}());\nvar /** @type {?} */ _MatChipListMixinBase = mixinErrorState(MatChipListBase);\n// Increasing integer for generating unique ids for chip-list components.\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * Change event object that is emitted when the chip list value has changed.\n */\nvar  /**\n * Change event object that is emitted when the chip list value has changed.\n */\nMatChipListChange = /** @class */ (function () {\n    function MatChipListChange(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n    return MatChipListChange;\n}());\n/**\n * A material design chips component (named ChipList for it's similarity to the List component).\n */\nvar MatChipList = /** @class */ (function (_super) {\n    __extends(MatChipList, _super);\n    function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, /** @docs-private */\n    ngControl) {\n        var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n        _this._elementRef = _elementRef;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._dir = _dir;\n        _this.ngControl = ngControl;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        _this.controlType = 'mat-chip-list';\n        /**\n         * When a chip is destroyed, we track the index so we can focus the appropriate next chip.\n         */\n        _this._lastDestroyedIndex = null;\n        /**\n         * Track which chips we're listening to for focus/destruction.\n         */\n        _this._chipSet = new WeakMap();\n        /**\n         * Subscription to tabbing out from the chip list.\n         */\n        _this._tabOutSubscription = Subscription.EMPTY;\n        /**\n         * Uid of the chip list\n         */\n        _this._uid = \"mat-chip-list-\" + nextUniqueId++;\n        /**\n         * Tab index for the chip list.\n         */\n        _this._tabIndex = 0;\n        /**\n         * User defined tab index.\n         * When it is not null, use user defined tab index. Otherwise use _tabIndex\n         */\n        _this._userTabIndex = null;\n        /**\n         * Function when touched\n         */\n        _this._onTouched = function () { };\n        /**\n         * Function when changed\n         */\n        _this._onChange = function () { };\n        _this._multiple = false;\n        _this._compareWith = function (o1, o2) { return o1 === o2; };\n        _this._required = false;\n        _this._disabled = false;\n        /**\n         * Orientation of the chip list.\n         */\n        _this.ariaOrientation = 'horizontal';\n        _this._selectable = true;\n        /**\n         * Event emitted when the selected chip list value has been changed by the user.\n         */\n        _this.change = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         * \\@docs-private\n         */\n        _this.valueChange = new EventEmitter();\n        if (_this.ngControl) {\n            _this.ngControl.valueAccessor = _this;\n        }\n        return _this;\n    }\n    Object.defineProperty(MatChipList.prototype, \"selected\", {\n        /** The array of selected chips inside chip list. */\n        get: /**\n         * The array of selected chips inside chip list.\n         * @return {?}\n         */\n        function () {\n            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"role\", {\n        /** The ARIA role applied to the chip list. */\n        get: /**\n         * The ARIA role applied to the chip list.\n         * @return {?}\n         */\n        function () { return this.empty ? null : 'listbox'; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"multiple\", {\n        get: /**\n         * Whether the user should be allowed to select multiple chips.\n         * @return {?}\n         */\n        function () { return this._multiple; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._multiple = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"compareWith\", {\n        get: /**\n         * A function to compare the option values with the selected values. The first argument\n         * is a value from an option. The second is a value from the selection. A boolean\n         * should be returned.\n         * @return {?}\n         */\n        function () { return this._compareWith; },\n        set: /**\n         * @param {?} fn\n         * @return {?}\n         */\n        function (fn) {\n            this._compareWith = fn;\n            if (this._selectionModel) {\n                // A different comparator means the selection could change.\n                this._initializeSelection();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"value\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this.writeValue(value);\n            this._value = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"id\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this._chipInput ? this._chipInput.id : this._uid;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"required\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._required = coerceBooleanProperty(value);\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"placeholder\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._placeholder = value;\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"focused\", {\n        /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n        get: /**\n         * Whether any chips or the matChipInput inside of this chip-list has focus.\n         * @return {?}\n         */\n        function () {\n            return this.chips.some(function (chip) { return chip._hasFocus; }) ||\n                (this._chipInput && this._chipInput.focused);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"empty\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"shouldLabelFloat\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return !this.empty || this.focused; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"disabled\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._disabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"selectable\", {\n        get: /**\n         * Whether or not this chip list is selectable. When a chip list is not selectable,\n         * the selected states for all the chips inside the chip list are always ignored.\n         * @return {?}\n         */\n        function () { return this._selectable; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var _this = this;\n            this._selectable = coerceBooleanProperty(value);\n            if (this.chips) {\n                this.chips.forEach(function (chip) { return chip.chipListSelectable = _this._selectable; });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"tabIndex\", {\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._userTabIndex = value;\n            this._tabIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipSelectionChanges\", {\n        /** Combined stream of all of the child chips' selection change events. */\n        get: /**\n         * Combined stream of all of the child chips' selection change events.\n         * @return {?}\n         */\n        function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip.selectionChange; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipFocusChanges\", {\n        /** Combined stream of all of the child chips' focus change events. */\n        get: /**\n         * Combined stream of all of the child chips' focus change events.\n         * @return {?}\n         */\n        function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip._onFocus; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipBlurChanges\", {\n        /** Combined stream of all of the child chips' blur change events. */\n        get: /**\n         * Combined stream of all of the child chips' blur change events.\n         * @return {?}\n         */\n        function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip._onBlur; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipRemoveChanges\", {\n        /** Combined stream of all of the child chips' remove change events. */\n        get: /**\n         * Combined stream of all of the child chips' remove change events.\n         * @return {?}\n         */\n        function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip.destroyed; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._keyManager = new FocusKeyManager(this.chips)\n            .withWrap()\n            .withVerticalOrientation()\n            .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');\n        // Prevents the chip list from capturing focus and redirecting\n        // it back to the first chip when the user tabs out.\n        this._tabOutSubscription = this._keyManager.tabOut.subscribe(function () {\n            _this._tabIndex = -1;\n            setTimeout(function () { return _this._tabIndex = _this._userTabIndex || 0; });\n        });\n        // When the list changes, re-subscribe\n        this._changeSubscription = this.chips.changes.pipe(startWith(null)).subscribe(function () {\n            _this._resetChips();\n            // Reset chips selected/deselected status\n            // Reset chips selected/deselected status\n            _this._initializeSelection();\n            // Check to see if we need to update our tab index\n            // Check to see if we need to update our tab index\n            _this._updateTabIndex();\n            // Check to see if we have a destroyed chip and need to refocus\n            // Check to see if we have a destroyed chip and need to refocus\n            _this._updateFocusForDestroyedChips();\n            _this.stateChanges.next();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._selectionModel = new SelectionModel(this.multiple, undefined, false);\n        this.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._tabOutSubscription.unsubscribe();\n        if (this._changeSubscription) {\n            this._changeSubscription.unsubscribe();\n        }\n        if (this._chipRemoveSubscription) {\n            this._chipRemoveSubscription.unsubscribe();\n        }\n        this._dropSubscriptions();\n        this.stateChanges.complete();\n    };\n    /** Associates an HTML input element with this chip list. */\n    /**\n     * Associates an HTML input element with this chip list.\n     * @param {?} inputElement\n     * @return {?}\n     */\n    MatChipList.prototype.registerInput = /**\n     * Associates an HTML input element with this chip list.\n     * @param {?} inputElement\n     * @return {?}\n     */\n    function (inputElement) {\n        this._chipInput = inputElement;\n    };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    MatChipList.prototype.setDescribedByIds = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    function (ids) { this._ariaDescribedby = ids.join(' '); };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MatChipList.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        if (this.chips) {\n            this._setSelectionByValue(value, false);\n        }\n    };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatChipList.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._onChange = fn;\n    };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatChipList.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._onTouched = fn;\n    };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    MatChipList.prototype.setDisabledState = /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    function (isDisabled) {\n        this.disabled = isDisabled;\n        this._elementRef.nativeElement.disabled = isDisabled;\n        this.stateChanges.next();\n    };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    MatChipList.prototype.onContainerClick = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () { this.focus(); };\n    /**\n     * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     */\n    /**\n     * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     * @return {?}\n     */\n    MatChipList.prototype.focus = /**\n     * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     * @return {?}\n     */\n    function () {\n        // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n        // Focus on first element if there's no chipInput inside chip-list\n        if (this._chipInput && this._chipInput.focused) {\n            // do nothing\n        }\n        else if (this.chips.length > 0) {\n            this._keyManager.setFirstItemActive();\n            this.stateChanges.next();\n        }\n        else {\n            this._focusInput();\n            this.stateChanges.next();\n        }\n    };\n    /** Attempt to focus an input if we have one. */\n    /**\n     * Attempt to focus an input if we have one.\n     * @return {?}\n     */\n    MatChipList.prototype._focusInput = /**\n     * Attempt to focus an input if we have one.\n     * @return {?}\n     */\n    function () {\n        if (this._chipInput) {\n            this._chipInput.focus();\n        }\n    };\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     */\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChipList.prototype._keydown = /**\n     * Pass events to the keyboard manager. Available here for tests.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ target = /** @type {?} */ (event.target);\n        // If they are on an empty input and hit backspace, focus the last chip\n        if (event.keyCode === BACKSPACE && this._isInputEmpty(target)) {\n            this._keyManager.setLastItemActive();\n            event.preventDefault();\n        }\n        else if (target && target.classList.contains('mat-chip')) {\n            this._keyManager.onKeydown(event);\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     */\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     * @return {?}\n     */\n    MatChipList.prototype._updateTabIndex = /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     * @return {?}\n     */\n    function () {\n        // If we have 0 chips, we should not allow keyboard focus\n        this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n    };\n    /**\n     * Update key manager's active item when chip is deleted.\n     * If the deleted chip is the last chip in chip list, focus the new last chip.\n     * Otherwise focus the next chip in the list.\n     * Save `_lastDestroyedIndex` so we can set the correct focus.\n     */\n    /**\n     * Update key manager's active item when chip is deleted.\n     * If the deleted chip is the last chip in chip list, focus the new last chip.\n     * Otherwise focus the next chip in the list.\n     * Save `_lastDestroyedIndex` so we can set the correct focus.\n     * @param {?} chip\n     * @return {?}\n     */\n    MatChipList.prototype._updateKeyManager = /**\n     * Update key manager's active item when chip is deleted.\n     * If the deleted chip is the last chip in chip list, focus the new last chip.\n     * Otherwise focus the next chip in the list.\n     * Save `_lastDestroyedIndex` so we can set the correct focus.\n     * @param {?} chip\n     * @return {?}\n     */\n    function (chip) {\n        var /** @type {?} */ chipIndex = this.chips.toArray().indexOf(chip);\n        if (this._isValidIndex(chipIndex)) {\n            if (chip._hasFocus) {\n                // Check whether the chip is not the last item\n                if (chipIndex < this.chips.length - 1) {\n                    this._keyManager.setActiveItem(chipIndex);\n                }\n                else if (chipIndex - 1 >= 0) {\n                    this._keyManager.setActiveItem(chipIndex - 1);\n                }\n            }\n            if (this._keyManager.activeItemIndex === chipIndex) {\n                this._lastDestroyedIndex = chipIndex;\n            }\n        }\n    };\n    /**\n     * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n     * one.\n     */\n    /**\n     * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n     * one.\n     * @return {?}\n     */\n    MatChipList.prototype._updateFocusForDestroyedChips = /**\n     * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n     * one.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ chipsArray = this.chips;\n        if (this._lastDestroyedIndex != null && chipsArray.length > 0 && this.focused) {\n            // Check whether the destroyed chip was the last item\n            var /** @type {?} */ newFocusIndex = Math.min(this._lastDestroyedIndex, chipsArray.length - 1);\n            this._keyManager.setActiveItem(newFocusIndex);\n            var /** @type {?} */ focusChip = this._keyManager.activeItem;\n            // Focus the chip\n            if (focusChip) {\n                focusChip.focus();\n            }\n        }\n        // Reset our destroyed index\n        this._lastDestroyedIndex = null;\n    };\n    /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of chips.\n     */\n    MatChipList.prototype._isValidIndex = /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of chips.\n     */\n    function (index) {\n        return index >= 0 && index < this.chips.length;\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    MatChipList.prototype._isInputEmpty = /**\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        if (element && element.nodeName.toLowerCase() === 'input') {\n            var /** @type {?} */ input = /** @type {?} */ (element);\n            return !input.value;\n        }\n        return false;\n    };\n    /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MatChipList.prototype._setSelectionByValue = /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    function (value, isUserInput) {\n        var _this = this;\n        if (isUserInput === void 0) { isUserInput = true; }\n        this._clearSelection();\n        this.chips.forEach(function (chip) { return chip.deselect(); });\n        if (Array.isArray(value)) {\n            value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\n            this._sortValues();\n        }\n        else {\n            var /** @type {?} */ correspondingChip = this._selectValue(value, isUserInput);\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what chip the user interacted with last.\n            if (correspondingChip) {\n                if (isUserInput) {\n                    this._keyManager.setActiveItem(correspondingChip);\n                }\n            }\n        }\n    };\n    /**\n     * Finds and selects the chip based on its value.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Chip that has the corresponding value.\n     */\n    MatChipList.prototype._selectValue = /**\n     * Finds and selects the chip based on its value.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Chip that has the corresponding value.\n     */\n    function (value, isUserInput) {\n        var _this = this;\n        if (isUserInput === void 0) { isUserInput = true; }\n        var /** @type {?} */ correspondingChip = this.chips.find(function (chip) {\n            return chip.value != null && _this._compareWith(chip.value, value);\n        });\n        if (correspondingChip) {\n            isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n            this._selectionModel.select(correspondingChip);\n        }\n        return correspondingChip;\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._initializeSelection = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(function () {\n            if (_this.ngControl || _this._value) {\n                _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);\n                _this.stateChanges.next();\n            }\n        });\n    };\n    /**\n     * Deselects every chip in the list.\n     * @param {?=} skip Chip that should not be deselected.\n     * @return {?}\n     */\n    MatChipList.prototype._clearSelection = /**\n     * Deselects every chip in the list.\n     * @param {?=} skip Chip that should not be deselected.\n     * @return {?}\n     */\n    function (skip) {\n        this._selectionModel.clear();\n        this.chips.forEach(function (chip) {\n            if (chip !== skip) {\n                chip.deselect();\n            }\n        });\n        this.stateChanges.next();\n    };\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @return {?}\n     */\n    MatChipList.prototype._sortValues = /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._multiple) {\n            this._selectionModel.clear();\n            this.chips.forEach(function (chip) {\n                if (chip.selected) {\n                    _this._selectionModel.select(chip);\n                }\n            });\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * Emits change event to set the model value.\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n    MatChipList.prototype._propagateChanges = /**\n     * Emits change event to set the model value.\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n    function (fallbackValue) {\n        var /** @type {?} */ valueToEmit = null;\n        if (Array.isArray(this.selected)) {\n            valueToEmit = this.selected.map(function (chip) { return chip.value; });\n        }\n        else {\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\n        }\n        this._value = valueToEmit;\n        this.change.emit(new MatChipListChange(this, valueToEmit));\n        this.valueChange.emit(valueToEmit);\n        this._onChange(valueToEmit);\n        this._changeDetectorRef.markForCheck();\n    };\n    /** When blurred, mark the field as touched when focus moved outside the chip list. */\n    /**\n     * When blurred, mark the field as touched when focus moved outside the chip list.\n     * @return {?}\n     */\n    MatChipList.prototype._blur = /**\n     * When blurred, mark the field as touched when focus moved outside the chip list.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._keyManager.setActiveItem(-1);\n        if (!this.disabled) {\n            if (this._chipInput) {\n                // If there's a chip input, we should check whether the focus moved to chip input.\n                // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                // to chip input, do nothing.\n                // Timeout is needed to wait for the focus() event trigger on chip input.\n                setTimeout(function () {\n                    if (!_this.focused) {\n                        _this._markAsTouched();\n                    }\n                });\n            }\n            else {\n                // If there's no chip input, then mark the field as touched.\n                this._markAsTouched();\n            }\n        }\n    };\n    /** Mark the field as touched */\n    /**\n     * Mark the field as touched\n     * @return {?}\n     */\n    MatChipList.prototype._markAsTouched = /**\n     * Mark the field as touched\n     * @return {?}\n     */\n    function () {\n        this._onTouched();\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._resetChips = /**\n     * @return {?}\n     */\n    function () {\n        this._dropSubscriptions();\n        this._listenToChipsFocus();\n        this._listenToChipsSelection();\n        this._listenToChipsRemoved();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._dropSubscriptions = /**\n     * @return {?}\n     */\n    function () {\n        if (this._chipFocusSubscription) {\n            this._chipFocusSubscription.unsubscribe();\n            this._chipFocusSubscription = null;\n        }\n        if (this._chipBlurSubscription) {\n            this._chipBlurSubscription.unsubscribe();\n            this._chipBlurSubscription = null;\n        }\n        if (this._chipSelectionSubscription) {\n            this._chipSelectionSubscription.unsubscribe();\n            this._chipSelectionSubscription = null;\n        }\n    };\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsSelection = /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(function (event) {\n            event.source.selected\n                ? _this._selectionModel.select(event.source)\n                : _this._selectionModel.deselect(event.source);\n            // For single selection chip list, make sure the deselected value is unselected.\n            if (!_this.multiple) {\n                _this.chips.forEach(function (chip) {\n                    if (!_this._selectionModel.isSelected(chip) && chip.selected) {\n                        chip.deselect();\n                    }\n                });\n            }\n            if (event.isUserInput) {\n                _this._propagateChanges();\n            }\n        });\n    };\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsFocus = /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._chipFocusSubscription = this.chipFocusChanges.subscribe(function (event) {\n            var /** @type {?} */ chipIndex = _this.chips.toArray().indexOf(event.chip);\n            if (_this._isValidIndex(chipIndex)) {\n                _this._keyManager.updateActiveItemIndex(chipIndex);\n            }\n            _this.stateChanges.next();\n        });\n        this._chipBlurSubscription = this.chipBlurChanges.subscribe(function () {\n            _this._blur();\n            _this.stateChanges.next();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsRemoved = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(function (event) {\n            _this._updateKeyManager(event.chip);\n        });\n    };\n    MatChipList.decorators = [\n        { type: Component, args: [{selector: 'mat-chip-list',\n                    template: \"<div class=\\\"mat-chip-list-wrapper\\\"><ng-content></ng-content></div>\",\n                    exportAs: 'matChipList',\n                    host: {\n                        '[attr.tabindex]': '_tabIndex',\n                        '[attr.aria-describedby]': '_ariaDescribedby || null',\n                        '[attr.aria-required]': 'required.toString()',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.aria-invalid]': 'errorState',\n                        '[attr.aria-multiselectable]': 'multiple',\n                        '[attr.role]': 'role',\n                        '[class.mat-chip-list-disabled]': 'disabled',\n                        '[class.mat-chip-list-invalid]': 'errorState',\n                        '[class.mat-chip-list-required]': 'required',\n                        '[attr.aria-orientation]': 'ariaOrientation',\n                        'class': 'mat-chip-list',\n                        '(focus)': 'focus()',\n                        '(blur)': '_blur()',\n                        '(keydown)': '_keydown($event)',\n                        '[id]': '_uid',\n                    },\n                    providers: [{ provide: MatFormFieldControl, useExisting: MatChipList }],\n                    styles: [\".mat-chip{position:relative;overflow:hidden;box-sizing:border-box}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:inline-flex;padding:7px 12px;border-radius:24px;align-items:center;cursor:default}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip:focus{box-shadow:0 3px 3px -2px rgba(0,0,0,.2),0 3px 4px 0 rgba(0,0,0,.14),0 1px 8px 0 rgba(0,0,0,.12);outline:0}@media screen and (-ms-high-contrast:active){.mat-standard-chip{outline:solid 1px}}.mat-standard-chip.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:7px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:7px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:7px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:7px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:32px;height:32px;margin-right:8px;margin-left:0}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:0}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:7px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:7px;margin-left:0}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper .mat-standard-chip,.mat-chip-list-wrapper input.mat-input-element{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden}input.mat-chip-input{width:150px;margin:3px;flex:1 0 150px}\"],\n                    encapsulation: ViewEncapsulation.None,\n                    changeDetection: ChangeDetectionStrategy.OnPush\n                },] },\n    ];\n    /** @nocollapse */\n    MatChipList.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ChangeDetectorRef, },\n        { type: Directionality, decorators: [{ type: Optional },] },\n        { type: NgForm, decorators: [{ type: Optional },] },\n        { type: FormGroupDirective, decorators: [{ type: Optional },] },\n        { type: ErrorStateMatcher, },\n        { type: NgControl, decorators: [{ type: Optional }, { type: Self },] },\n    ]; };\n    MatChipList.propDecorators = {\n        \"errorStateMatcher\": [{ type: Input },],\n        \"multiple\": [{ type: Input },],\n        \"compareWith\": [{ type: Input },],\n        \"value\": [{ type: Input },],\n        \"required\": [{ type: Input },],\n        \"placeholder\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"ariaOrientation\": [{ type: Input, args: ['aria-orientation',] },],\n        \"selectable\": [{ type: Input },],\n        \"tabIndex\": [{ type: Input },],\n        \"change\": [{ type: Output },],\n        \"valueChange\": [{ type: Output },],\n        \"chips\": [{ type: ContentChildren, args: [MatChip,] },],\n    };\n    return MatChipList;\n}(_MatChipListMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Increasing integer for generating unique ids.\nvar /** @type {?} */ nextUniqueId$1 = 0;\n/**\n * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n * May be placed inside or outside of an `<mat-chip-list>`.\n */\nvar MatChipInput = /** @class */ (function () {\n    function MatChipInput(_elementRef, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._defaultOptions = _defaultOptions;\n        /**\n         * Whether the control is focused.\n         */\n        this.focused = false;\n        this._addOnBlur = false;\n        /**\n         * The list of key codes that will trigger a chipEnd event.\n         *\n         * Defaults to `[ENTER]`.\n         */\n        this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;\n        /**\n         * Emitted when a chip is to be added.\n         */\n        this.chipEnd = new EventEmitter();\n        /**\n         * The input's placeholder text.\n         * @deprecated Bind to the `placeholder` attribute directly.\n         * \\@deletion-target 7.0.0\n         */\n        this.placeholder = '';\n        /**\n         * Unique id for the input.\n         */\n        this.id = \"mat-chip-list-input-\" + nextUniqueId$1++;\n        this._inputElement = /** @type {?} */ (this._elementRef.nativeElement);\n    }\n    Object.defineProperty(MatChipInput.prototype, \"chipList\", {\n        set: /**\n         * Register input for chip list\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value) {\n                this._chipList = value;\n                this._chipList.registerInput(this);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipInput.prototype, \"addOnBlur\", {\n        get: /**\n         * Whether or not the chipEnd event will be emitted when the input is blurred.\n         * @return {?}\n         */\n        function () { return this._addOnBlur; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._addOnBlur = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipInput.prototype, \"empty\", {\n        /** Whether the input is empty. */\n        get: /**\n         * Whether the input is empty.\n         * @return {?}\n         */\n        function () { return !this._inputElement.value; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Utility method to make host definition/tests more clear. */\n    /**\n     * Utility method to make host definition/tests more clear.\n     * @param {?=} event\n     * @return {?}\n     */\n    MatChipInput.prototype._keydown = /**\n     * Utility method to make host definition/tests more clear.\n     * @param {?=} event\n     * @return {?}\n     */\n    function (event) {\n        this._emitChipEnd(event);\n    };\n    /** Checks to see if the blur should emit the (chipEnd) event. */\n    /**\n     * Checks to see if the blur should emit the (chipEnd) event.\n     * @return {?}\n     */\n    MatChipInput.prototype._blur = /**\n     * Checks to see if the blur should emit the (chipEnd) event.\n     * @return {?}\n     */\n    function () {\n        if (this.addOnBlur) {\n            this._emitChipEnd();\n        }\n        this.focused = false;\n        // Blur the chip list if it is not focused\n        if (!this._chipList.focused) {\n            this._chipList._blur();\n        }\n        this._chipList.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipInput.prototype._focus = /**\n     * @return {?}\n     */\n    function () {\n        this.focused = true;\n        this._chipList.stateChanges.next();\n    };\n    /** Checks to see if the (chipEnd) event needs to be emitted. */\n    /**\n     * Checks to see if the (chipEnd) event needs to be emitted.\n     * @param {?=} event\n     * @return {?}\n     */\n    MatChipInput.prototype._emitChipEnd = /**\n     * Checks to see if the (chipEnd) event needs to be emitted.\n     * @param {?=} event\n     * @return {?}\n     */\n    function (event) {\n        if (!this._inputElement.value && !!event) {\n            this._chipList._keydown(event);\n        }\n        if (!event || this.separatorKeyCodes.indexOf(event.keyCode) > -1) {\n            this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n            if (event) {\n                event.preventDefault();\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatChipInput.prototype._onInput = /**\n     * @return {?}\n     */\n    function () {\n        // Let chip list know whenever the value changes.\n        this._chipList.stateChanges.next();\n    };\n    /** Focuses the input. */\n    /**\n     * Focuses the input.\n     * @return {?}\n     */\n    MatChipInput.prototype.focus = /**\n     * Focuses the input.\n     * @return {?}\n     */\n    function () { this._inputElement.focus(); };\n    MatChipInput.decorators = [\n        { type: Directive, args: [{\n                    selector: 'input[matChipInputFor]',\n                    exportAs: 'matChipInput, matChipInputFor',\n                    host: {\n                        'class': 'mat-chip-input mat-input-element',\n                        '(keydown)': '_keydown($event)',\n                        '(blur)': '_blur()',\n                        '(focus)': '_focus()',\n                        '(input)': '_onInput()',\n                        '[id]': 'id',\n                        '[attr.placeholder]': 'placeholder || null',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    MatChipInput.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_CHIPS_DEFAULT_OPTIONS,] },] },\n    ]; };\n    MatChipInput.propDecorators = {\n        \"chipList\": [{ type: Input, args: ['matChipInputFor',] },],\n        \"addOnBlur\": [{ type: Input, args: ['matChipInputAddOnBlur',] },],\n        \"separatorKeyCodes\": [{ type: Input, args: ['matChipInputSeparatorKeyCodes',] },],\n        \"chipEnd\": [{ type: Output, args: ['matChipInputTokenEnd',] },],\n        \"placeholder\": [{ type: Input },],\n        \"id\": [{ type: Input },],\n    };\n    return MatChipInput;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ CHIP_DECLARATIONS = [\n    MatChipList,\n    MatChip,\n    MatChipInput,\n    MatChipRemove,\n    MatChipAvatar,\n    MatChipTrailingIcon,\n];\nvar ɵ0 = {\n    separatorKeyCodes: [ENTER]\n};\nvar MatChipsModule = /** @class */ (function () {\n    function MatChipsModule() {\n    }\n    MatChipsModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: CHIP_DECLARATIONS,\n                    declarations: CHIP_DECLARATIONS,\n                    providers: [\n                        ErrorStateMatcher,\n                        {\n                            provide: MAT_CHIPS_DEFAULT_OPTIONS,\n                            useValue: /** @type {?} */ ((ɵ0))\n                        }\n                    ]\n                },] },\n    ];\n    return MatChipsModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MatChipsModule, MatChipListBase, _MatChipListMixinBase, MatChipListChange, MatChipList, MatChipSelectionChange, MatChipBase, _MatChipMixinBase, MatChipAvatar, MatChipTrailingIcon, MatChip, MatChipRemove, MatChipInput, MAT_CHIPS_DEFAULT_OPTIONS };\n//# sourceMappingURL=chips.es5.js.map\n",
    "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, Input, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, Inject, InjectionToken, Optional, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { __extends } from 'tslib';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { MAT_LABEL_GLOBAL_OPTIONS, mixinColor } from '@angular/material/core';\nimport { EMPTY, fromEvent, merge } from 'rxjs';\nimport { startWith, take } from 'rxjs/operators';\nimport { Platform } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * Single error message to be shown underneath the form field.\n */\nvar MatError = /** @class */ (function () {\n    function MatError() {\n        this.id = \"mat-error-\" + nextUniqueId++;\n    }\n    MatError.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-error',\n                    host: {\n                        'class': 'mat-error',\n                        'role': 'alert',\n                        '[attr.id]': 'id',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    MatError.propDecorators = {\n        \"id\": [{ type: Input },],\n    };\n    return MatError;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the MatFormField.\n */\nvar /** @type {?} */ matFormFieldAnimations = {\n    /** Animation that transitions the form field's error and hint messages. */\n    transitionMessages: trigger('transitionMessages', [\n        // TODO(mmalerba): Use angular animations for label animation as well.\n        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),\n        transition('void => enter', [\n            style({ opacity: 0, transform: 'translateY(-100%)' }),\n            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),\n        ]),\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * An interface which allows a control to work inside of a `MatFormField`.\n * @abstract\n * @template T\n */\nvar  /**\n * An interface which allows a control to work inside of a `MatFormField`.\n * @abstract\n * @template T\n */\nMatFormFieldControl = /** @class */ (function () {\n    function MatFormFieldControl() {\n    }\n    return MatFormFieldControl;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getMatFormFieldPlaceholderConflictError() {\n    return Error('Placeholder attribute and child element were both specified.');\n}\n/**\n * \\@docs-private\n * @param {?} align\n * @return {?}\n */\nfunction getMatFormFieldDuplicatedHintError(align) {\n    return Error(\"A hint was already declared for 'align=\\\"\" + align + \"\\\"'.\");\n}\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getMatFormFieldMissingControlError() {\n    return Error('mat-form-field must contain a MatFormFieldControl.');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ nextUniqueId$1 = 0;\n/**\n * Hint text to be shown underneath the form field control.\n */\nvar MatHint = /** @class */ (function () {\n    function MatHint() {\n        /**\n         * Whether to align the hint label at the start or end of the line.\n         */\n        this.align = 'start';\n        /**\n         * Unique ID for the hint. Used for the aria-describedby on the form field control.\n         */\n        this.id = \"mat-hint-\" + nextUniqueId$1++;\n    }\n    MatHint.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-hint',\n                    host: {\n                        'class': 'mat-hint',\n                        '[class.mat-right]': 'align == \"end\"',\n                        '[attr.id]': 'id',\n                        // Remove align attribute to prevent it from interfering with layout.\n                        '[attr.align]': 'null',\n                    }\n                },] },\n    ];\n    /** @nocollapse */\n    MatHint.propDecorators = {\n        \"align\": [{ type: Input },],\n        \"id\": [{ type: Input },],\n    };\n    return MatHint;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The floating label for a `mat-form-field`.\n */\nvar MatLabel = /** @class */ (function () {\n    function MatLabel() {\n    }\n    MatLabel.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-label'\n                },] },\n    ];\n    return MatLabel;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The placeholder text for an `MatFormField`.\n * @deprecated Use `<mat-label>` to specify the label and the `placeholder` attribute to specify the\n *     placeholder.\n * \\@deletion-target 8.0.0\n */\nvar MatPlaceholder = /** @class */ (function () {\n    function MatPlaceholder() {\n    }\n    MatPlaceholder.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-placeholder'\n                },] },\n    ];\n    return MatPlaceholder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Prefix to be placed the the front of the form field.\n */\nvar MatPrefix = /** @class */ (function () {\n    function MatPrefix() {\n    }\n    MatPrefix.decorators = [\n        { type: Directive, args: [{\n                    selector: '[matPrefix]',\n                },] },\n    ];\n    return MatPrefix;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Suffix to be placed at the end of the form field.\n */\nvar MatSuffix = /** @class */ (function () {\n    function MatSuffix() {\n    }\n    MatSuffix.decorators = [\n        { type: Directive, args: [{\n                    selector: '[matSuffix]',\n                },] },\n    ];\n    return MatSuffix;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ nextUniqueId$2 = 0;\nvar /** @type {?} */ floatingLabelScale = 0.75;\nvar /** @type {?} */ outlineGapPadding = 5;\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatFormFieldBase = /** @class */ (function () {\n    function MatFormFieldBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatFormFieldBase;\n}());\nvar /** @type {?} */ _MatFormFieldMixinBase = mixinColor(MatFormFieldBase, 'primary');\nvar /** @type {?} */ MAT_FORM_FIELD_DEFAULT_OPTIONS = new InjectionToken('MAT_FORM_FIELD_DEFAULT_OPTIONS');\n/**\n * Container for form controls that applies Material Design styling and behavior.\n */\nvar MatFormField = /** @class */ (function (_super) {\n    __extends(MatFormField, _super);\n    function MatFormField(_elementRef, _changeDetectorRef, labelOptions, _dir, _defaultOptions, _platform) {\n        var _this = _super.call(this, _elementRef) || this;\n        _this._elementRef = _elementRef;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._dir = _dir;\n        _this._defaultOptions = _defaultOptions;\n        _this._platform = _platform;\n        /**\n         * Override for the logic that disables the label animation in certain cases.\n         */\n        _this._showAlwaysAnimate = false;\n        /**\n         * State of the mat-hint and mat-error animations.\n         */\n        _this._subscriptAnimationState = '';\n        _this._hintLabel = '';\n        // Unique id for the hint label.\n        _this._hintLabelId = \"mat-hint-\" + nextUniqueId$2++;\n        _this._outlineGapWidth = 0;\n        _this._outlineGapStart = 0;\n        _this._initialGapCalculated = false;\n        _this._labelOptions = labelOptions ? labelOptions : {};\n        _this.floatLabel = _this._labelOptions.float || 'auto';\n        return _this;\n    }\n    Object.defineProperty(MatFormField.prototype, \"appearance\", {\n        get: /**\n         * The form-field appearance style.\n         * @return {?}\n         */\n        function () {\n            return this._appearance || this._defaultOptions && this._defaultOptions.appearance || 'legacy';\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._appearance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"hideRequiredMarker\", {\n        get: /**\n         * Whether the required marker should be hidden.\n         * @return {?}\n         */\n        function () { return this._hideRequiredMarker; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._hideRequiredMarker = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"_shouldAlwaysFloat\", {\n        /** Whether the floating label should always float or not. */\n        get: /**\n         * Whether the floating label should always float or not.\n         * @return {?}\n         */\n        function () {\n            return this.floatLabel === 'always' && !this._showAlwaysAnimate;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"_canLabelFloat\", {\n        /** Whether the label can float or not. */\n        get: /**\n         * Whether the label can float or not.\n         * @return {?}\n         */\n        function () { return this.floatLabel !== 'never'; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"hintLabel\", {\n        get: /**\n         * Text for the form field hint.\n         * @return {?}\n         */\n        function () { return this._hintLabel; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._hintLabel = value;\n            this._processHints();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"floatLabel\", {\n        get: /**\n         * Whether the label should always float, never float or float as the user types.\n         *\n         * Note: only the legacy appearance supports the `never` option. `never` was originally added as a\n         * way to make the floating label emulate the behavior of a standard input placeholder. However\n         * the form field now supports both floating labels and placeholders. Therefore in the non-legacy\n         * appearances the `never` option has been disabled in favor of just using the placeholder.\n         * @return {?}\n         */\n        function () {\n            return this.appearance !== 'legacy' && this._floatLabel === 'never' ? 'auto' : this._floatLabel;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value !== this._floatLabel) {\n                this._floatLabel = value || this._labelOptions.float || 'auto';\n                this._changeDetectorRef.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Gets an ElementRef for the element that a overlay attached to the form-field should be\n     * positioned relative to.\n     */\n    /**\n     * Gets an ElementRef for the element that a overlay attached to the form-field should be\n     * positioned relative to.\n     * @return {?}\n     */\n    MatFormField.prototype.getConnectedOverlayOrigin = /**\n     * Gets an ElementRef for the element that a overlay attached to the form-field should be\n     * positioned relative to.\n     * @return {?}\n     */\n    function () {\n        return this._connectionContainerRef || this._elementRef;\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._validateControlChild();\n        if (this._control.controlType) {\n            this._elementRef.nativeElement.classList\n                .add(\"mat-form-field-type-\" + this._control.controlType);\n        }\n        // Subscribe to changes in the child control state in order to update the form field UI.\n        this._control.stateChanges.pipe(startWith(/** @type {?} */ ((null)))).subscribe(function () {\n            _this._validatePlaceholders();\n            _this._syncDescribedByIds();\n            _this._changeDetectorRef.markForCheck();\n        });\n        // Run change detection if the value, prefix, or suffix changes.\n        var /** @type {?} */ valueChanges = this._control.ngControl && this._control.ngControl.valueChanges || EMPTY;\n        merge(valueChanges, this._prefixChildren.changes, this._suffixChildren.changes)\n            .subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n        // Re-validate when the number of hints changes.\n        this._hintChildren.changes.pipe(startWith(null)).subscribe(function () {\n            _this._processHints();\n            _this._changeDetectorRef.markForCheck();\n        });\n        // Update the aria-described by when the number of errors changes.\n        this._errorChildren.changes.pipe(startWith(null)).subscribe(function () {\n            _this._syncDescribedByIds();\n            _this._changeDetectorRef.markForCheck();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype.ngAfterContentChecked = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._validateControlChild();\n        if (!this._initialGapCalculated) {\n            Promise.resolve().then(function () { return _this.updateOutlineGap(); });\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        // Avoid animations on load.\n        this._subscriptAnimationState = 'enter';\n        this._changeDetectorRef.detectChanges();\n    };\n    /** Determines whether a class from the NgControl should be forwarded to the host element. */\n    /**\n     * Determines whether a class from the NgControl should be forwarded to the host element.\n     * @param {?} prop\n     * @return {?}\n     */\n    MatFormField.prototype._shouldForward = /**\n     * Determines whether a class from the NgControl should be forwarded to the host element.\n     * @param {?} prop\n     * @return {?}\n     */\n    function (prop) {\n        var /** @type {?} */ ngControl = this._control ? this._control.ngControl : null;\n        return ngControl && (/** @type {?} */ (ngControl))[prop];\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hasPlaceholder = /**\n     * @return {?}\n     */\n    function () {\n        return !!(this._control && this._control.placeholder || this._placeholderChild);\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hasLabel = /**\n     * @return {?}\n     */\n    function () {\n        return !!this._labelChild;\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._shouldLabelFloat = /**\n     * @return {?}\n     */\n    function () {\n        return this._canLabelFloat && (this._control.shouldLabelFloat || this._shouldAlwaysFloat);\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hideControlPlaceholder = /**\n     * @return {?}\n     */\n    function () {\n        // In the legacy appearance the placeholder is promoted to a label if no label is given.\n        return this.appearance === 'legacy' && !this._hasLabel() ||\n            this._hasLabel() && !this._shouldLabelFloat();\n    };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hasFloatingLabel = /**\n     * @return {?}\n     */\n    function () {\n        // In the legacy appearance the placeholder is promoted to a label if no label is given.\n        return this._hasLabel() || this.appearance === 'legacy' && this._hasPlaceholder();\n    };\n    /** Determines whether to display hints or errors. */\n    /**\n     * Determines whether to display hints or errors.\n     * @return {?}\n     */\n    MatFormField.prototype._getDisplayedMessages = /**\n     * Determines whether to display hints or errors.\n     * @return {?}\n     */\n    function () {\n        return (this._errorChildren && this._errorChildren.length > 0 &&\n            this._control.errorState) ? 'error' : 'hint';\n    };\n    /** Animates the placeholder up and locks it in position. */\n    /**\n     * Animates the placeholder up and locks it in position.\n     * @return {?}\n     */\n    MatFormField.prototype._animateAndLockLabel = /**\n     * Animates the placeholder up and locks it in position.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._hasFloatingLabel() && this._canLabelFloat) {\n            this._showAlwaysAnimate = true;\n            this.floatLabel = 'always';\n            fromEvent(this._label.nativeElement, 'transitionend').pipe(take(1)).subscribe(function () {\n                _this._showAlwaysAnimate = false;\n            });\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /**\n     * Ensure that there is only one placeholder (either `placeholder` attribute on the child control\n     * or child element with the `mat-placeholder` directive).\n     * @return {?}\n     */\n    MatFormField.prototype._validatePlaceholders = /**\n     * Ensure that there is only one placeholder (either `placeholder` attribute on the child control\n     * or child element with the `mat-placeholder` directive).\n     * @return {?}\n     */\n    function () {\n        if (this._control.placeholder && this._placeholderChild) {\n            throw getMatFormFieldPlaceholderConflictError();\n        }\n    };\n    /**\n     * Does any extra processing that is required when handling the hints.\n     * @return {?}\n     */\n    MatFormField.prototype._processHints = /**\n     * Does any extra processing that is required when handling the hints.\n     * @return {?}\n     */\n    function () {\n        this._validateHints();\n        this._syncDescribedByIds();\n    };\n    /**\n     * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the\n     * attribute being considered as `align=\"start\"`.\n     * @return {?}\n     */\n    MatFormField.prototype._validateHints = /**\n     * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the\n     * attribute being considered as `align=\"start\"`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._hintChildren) {\n            var /** @type {?} */ startHint_1;\n            var /** @type {?} */ endHint_1;\n            this._hintChildren.forEach(function (hint) {\n                if (hint.align === 'start') {\n                    if (startHint_1 || _this.hintLabel) {\n                        throw getMatFormFieldDuplicatedHintError('start');\n                    }\n                    startHint_1 = hint;\n                }\n                else if (hint.align === 'end') {\n                    if (endHint_1) {\n                        throw getMatFormFieldDuplicatedHintError('end');\n                    }\n                    endHint_1 = hint;\n                }\n            });\n        }\n    };\n    /**\n     * Sets the list of element IDs that describe the child control. This allows the control to update\n     * its `aria-describedby` attribute accordingly.\n     * @return {?}\n     */\n    MatFormField.prototype._syncDescribedByIds = /**\n     * Sets the list of element IDs that describe the child control. This allows the control to update\n     * its `aria-describedby` attribute accordingly.\n     * @return {?}\n     */\n    function () {\n        if (this._control) {\n            var /** @type {?} */ ids = [];\n            if (this._getDisplayedMessages() === 'hint') {\n                var /** @type {?} */ startHint = this._hintChildren ?\n                    this._hintChildren.find(function (hint) { return hint.align === 'start'; }) : null;\n                var /** @type {?} */ endHint = this._hintChildren ?\n                    this._hintChildren.find(function (hint) { return hint.align === 'end'; }) : null;\n                if (startHint) {\n                    ids.push(startHint.id);\n                }\n                else if (this._hintLabel) {\n                    ids.push(this._hintLabelId);\n                }\n                if (endHint) {\n                    ids.push(endHint.id);\n                }\n            }\n            else if (this._errorChildren) {\n                ids = this._errorChildren.map(function (error) { return error.id; });\n            }\n            this._control.setDescribedByIds(ids);\n        }\n    };\n    /** Throws an error if the form field's control is missing. */\n    /**\n     * Throws an error if the form field's control is missing.\n     * @return {?}\n     */\n    MatFormField.prototype._validateControlChild = /**\n     * Throws an error if the form field's control is missing.\n     * @return {?}\n     */\n    function () {\n        if (!this._control) {\n            throw getMatFormFieldMissingControlError();\n        }\n    };\n    /**\n     * Updates the width and position of the gap in the outline. Only relevant for the outline\n     * appearance.\n     */\n    /**\n     * Updates the width and position of the gap in the outline. Only relevant for the outline\n     * appearance.\n     * @return {?}\n     */\n    MatFormField.prototype.updateOutlineGap = /**\n     * Updates the width and position of the gap in the outline. Only relevant for the outline\n     * appearance.\n     * @return {?}\n     */\n    function () {\n        if (this.appearance === 'outline' && this._label && this._label.nativeElement.children.length) {\n            if (this._platform && !this._platform.isBrowser) {\n                // getBoundingClientRect isn't available on the server.\n                this._initialGapCalculated = true;\n                return;\n            }\n            if (!document.documentElement.contains(this._elementRef.nativeElement)) {\n                return;\n            }\n            var /** @type {?} */ containerStart = this._getStartEnd(this._connectionContainerRef.nativeElement.getBoundingClientRect());\n            var /** @type {?} */ labelStart = this._getStartEnd(this._label.nativeElement.children[0].getBoundingClientRect());\n            var /** @type {?} */ labelWidth = 0;\n            for (var _i = 0, _a = this._label.nativeElement.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                labelWidth += child.offsetWidth;\n            }\n            this._outlineGapStart = labelStart - containerStart - outlineGapPadding;\n            this._outlineGapWidth = labelWidth * floatingLabelScale + outlineGapPadding * 2;\n        }\n        else {\n            this._outlineGapStart = 0;\n            this._outlineGapWidth = 0;\n        }\n        this._initialGapCalculated = true;\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * Gets the start end of the rect considering the current directionality.\n     * @param {?} rect\n     * @return {?}\n     */\n    MatFormField.prototype._getStartEnd = /**\n     * Gets the start end of the rect considering the current directionality.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._dir && this._dir.value === 'rtl' ? rect.right : rect.left;\n    };\n    MatFormField.decorators = [\n        { type: Component, args: [{selector: 'mat-form-field',\n                    exportAs: 'matFormField',\n                    template: \"<div class=\\\"mat-form-field-wrapper\\\"><div class=\\\"mat-form-field-flex\\\" #connectionContainer (click)=\\\"_control.onContainerClick && _control.onContainerClick($event)\\\"><div class=\\\"mat-form-field-prefix\\\" *ngIf=\\\"_prefixChildren.length\\\"><ng-content select=\\\"[matPrefix]\\\"></ng-content></div><div class=\\\"mat-form-field-infix\\\" #inputContainer><ng-content></ng-content><span class=\\\"mat-form-field-label-wrapper\\\"><label class=\\\"mat-form-field-label\\\" [attr.for]=\\\"_control.id\\\" [attr.aria-owns]=\\\"_control.id\\\" [class.mat-empty]=\\\"_control.empty && !_shouldAlwaysFloat\\\" [class.mat-form-field-empty]=\\\"_control.empty && !_shouldAlwaysFloat\\\" [class.mat-accent]=\\\"color == 'accent'\\\" [class.mat-warn]=\\\"color == 'warn'\\\" #label *ngIf=\\\"_hasFloatingLabel()\\\" [ngSwitch]=\\\"_hasLabel()\\\"><ng-container *ngSwitchCase=\\\"false\\\"><ng-content select=\\\"mat-placeholder\\\"></ng-content>{{_control.placeholder}}</ng-container><ng-content select=\\\"mat-label\\\" *ngSwitchCase=\\\"true\\\"></ng-content><span class=\\\"mat-placeholder-required mat-form-field-required-marker\\\" aria-hidden=\\\"true\\\" *ngIf=\\\"!hideRequiredMarker && _control.required && !_control.disabled\\\">&nbsp;*</span></label></span></div><div class=\\\"mat-form-field-suffix\\\" *ngIf=\\\"_suffixChildren.length\\\"><ng-content select=\\\"[matSuffix]\\\"></ng-content></div></div><div class=\\\"mat-form-field-underline\\\" #underline *ngIf=\\\"appearance != 'outline'\\\"><span class=\\\"mat-form-field-ripple\\\" [class.mat-accent]=\\\"color == 'accent'\\\" [class.mat-warn]=\\\"color == 'warn'\\\"></span></div><ng-container *ngIf=\\\"appearance == 'outline'\\\"><div class=\\\"mat-form-field-outline\\\"><div class=\\\"mat-form-field-outline-start\\\" [style.width.px]=\\\"_outlineGapStart\\\"></div><div class=\\\"mat-form-field-outline-gap\\\" [style.width.px]=\\\"_outlineGapWidth\\\"></div><div class=\\\"mat-form-field-outline-end\\\"></div></div><div class=\\\"mat-form-field-outline mat-form-field-outline-thick\\\"><div class=\\\"mat-form-field-outline-start\\\" [style.width.px]=\\\"_outlineGapStart\\\"></div><div class=\\\"mat-form-field-outline-gap\\\" [style.width.px]=\\\"_outlineGapWidth\\\"></div><div class=\\\"mat-form-field-outline-end\\\"></div></div></ng-container><div class=\\\"mat-form-field-subscript-wrapper\\\" [ngSwitch]=\\\"_getDisplayedMessages()\\\"><div *ngSwitchCase=\\\"'error'\\\" [@transitionMessages]=\\\"_subscriptAnimationState\\\"><ng-content select=\\\"mat-error\\\"></ng-content></div><div class=\\\"mat-form-field-hint-wrapper\\\" *ngSwitchCase=\\\"'hint'\\\" [@transitionMessages]=\\\"_subscriptAnimationState\\\"><div *ngIf=\\\"hintLabel\\\" [id]=\\\"_hintLabelId\\\" class=\\\"mat-hint\\\">{{hintLabel}}</div><ng-content select=\\\"mat-hint:not([align='end'])\\\"></ng-content><div class=\\\"mat-form-field-hint-spacer\\\"></div><ng-content select=\\\"mat-hint[align='end']\\\"></ng-content></div></div></div>\",\n                    // MatInput is a directive and can't have styles, so we need to include its styles here.\n                    // The MatInput styles are fairly minimal so it shouldn't be a big deal for people who\n                    // aren't using MatInput.\n                    styles: [\".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-empty.mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scaleY(1.0001)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(.5);opacity:0;transition:background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:scaleX(1);transition:transform .3s cubic-bezier(.25,.8,.25,1),opacity .1s cubic-bezier(.25,.8,.25,1),background-color .3s cubic-bezier(.25,.8,.25,1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-label-wrapper .mat-icon,.mat-form-field-subscript-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block} .mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:'';display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em} .mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px} .mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-.25em}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:0;left:0;right:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-start{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start{border-width:2px;transition:border-color .3s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity .1s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline{opacity:0;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em} .mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity .6s cubic-bezier(.25,.8,.25,1)} .mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element[type=date]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=month]::after,.mat-input-element[type=time]::after,.mat-input-element[type=week]::after{content:' ';white-space:pre;width:1px}.mat-input-element::placeholder{transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element::-moz-placeholder{transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element::-webkit-input-placeholder{transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element:-ms-input-placeholder{transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent!important;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent!important;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent!important;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent!important;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}\"],\n                    animations: [matFormFieldAnimations.transitionMessages],\n                    host: {\n                        'class': 'mat-form-field',\n                        '[class.mat-form-field-appearance-standard]': 'appearance == \"standard\"',\n                        '[class.mat-form-field-appearance-fill]': 'appearance == \"fill\"',\n                        '[class.mat-form-field-appearance-outline]': 'appearance == \"outline\"',\n                        '[class.mat-form-field-appearance-legacy]': 'appearance == \"legacy\"',\n                        '[class.mat-form-field-invalid]': '_control.errorState',\n                        '[class.mat-form-field-can-float]': '_canLabelFloat',\n                        '[class.mat-form-field-should-float]': '_shouldLabelFloat()',\n                        '[class.mat-form-field-hide-placeholder]': '_hideControlPlaceholder()',\n                        '[class.mat-form-field-disabled]': '_control.disabled',\n                        '[class.mat-form-field-autofilled]': '_control.autofilled',\n                        '[class.mat-focused]': '_control.focused',\n                        '[class.mat-accent]': 'color == \"accent\"',\n                        '[class.mat-warn]': 'color == \"warn\"',\n                        '[class.ng-untouched]': '_shouldForward(\"untouched\")',\n                        '[class.ng-touched]': '_shouldForward(\"touched\")',\n                        '[class.ng-pristine]': '_shouldForward(\"pristine\")',\n                        '[class.ng-dirty]': '_shouldForward(\"dirty\")',\n                        '[class.ng-valid]': '_shouldForward(\"valid\")',\n                        '[class.ng-invalid]': '_shouldForward(\"invalid\")',\n                        '[class.ng-pending]': '_shouldForward(\"pending\")',\n                    },\n                    inputs: ['color'],\n                    encapsulation: ViewEncapsulation.None,\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                },] },\n    ];\n    /** @nocollapse */\n    MatFormField.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ChangeDetectorRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_LABEL_GLOBAL_OPTIONS,] },] },\n        { type: Directionality, decorators: [{ type: Optional },] },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_FORM_FIELD_DEFAULT_OPTIONS,] },] },\n        { type: Platform, },\n    ]; };\n    MatFormField.propDecorators = {\n        \"appearance\": [{ type: Input },],\n        \"hideRequiredMarker\": [{ type: Input },],\n        \"hintLabel\": [{ type: Input },],\n        \"floatLabel\": [{ type: Input },],\n        \"underlineRef\": [{ type: ViewChild, args: ['underline',] },],\n        \"_connectionContainerRef\": [{ type: ViewChild, args: ['connectionContainer',] },],\n        \"_inputContainerRef\": [{ type: ViewChild, args: ['inputContainer',] },],\n        \"_label\": [{ type: ViewChild, args: ['label',] },],\n        \"_control\": [{ type: ContentChild, args: [MatFormFieldControl,] },],\n        \"_placeholderChild\": [{ type: ContentChild, args: [MatPlaceholder,] },],\n        \"_labelChild\": [{ type: ContentChild, args: [MatLabel,] },],\n        \"_errorChildren\": [{ type: ContentChildren, args: [MatError,] },],\n        \"_hintChildren\": [{ type: ContentChildren, args: [MatHint,] },],\n        \"_prefixChildren\": [{ type: ContentChildren, args: [MatPrefix,] },],\n        \"_suffixChildren\": [{ type: ContentChildren, args: [MatSuffix,] },],\n    };\n    return MatFormField;\n}(_MatFormFieldMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatFormFieldModule = /** @class */ (function () {\n    function MatFormFieldModule() {\n    }\n    MatFormFieldModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        MatError,\n                        MatFormField,\n                        MatHint,\n                        MatLabel,\n                        MatPlaceholder,\n                        MatPrefix,\n                        MatSuffix,\n                    ],\n                    imports: [CommonModule],\n                    exports: [\n                        MatError,\n                        MatFormField,\n                        MatHint,\n                        MatLabel,\n                        MatPlaceholder,\n                        MatPrefix,\n                        MatSuffix,\n                    ],\n                },] },\n    ];\n    return MatFormFieldModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MatFormFieldModule, MatError, MatFormFieldBase, _MatFormFieldMixinBase, MAT_FORM_FIELD_DEFAULT_OPTIONS, MatFormField, MatFormFieldControl, getMatFormFieldPlaceholderConflictError, getMatFormFieldDuplicatedHintError, getMatFormFieldMissingControlError, MatHint, MatPlaceholder, MatPrefix, MatSuffix, MatLabel, matFormFieldAnimations };\n//# sourceMappingURL=form-field.es5.js.map\n",
    "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Inject, Optional, Self, NgZone, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n * \\@deletion-target 7.0.0 deprecate in favor of `cdkTextareaAutosize`.\n */\nvar MatTextareaAutosize = /** @class */ (function (_super) {\n    __extends(MatTextareaAutosize, _super);\n    function MatTextareaAutosize() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMinRows\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.minRows; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.minRows = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosizeMaxRows\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.maxRows; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.maxRows = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matAutosize\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.enabled = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTextareaAutosize.prototype, \"matTextareaAutosize\", {\n        get: /**\n         * @return {?}\n         */\n        function () { return this.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.enabled = value; },\n        enumerable: true,\n        configurable: true\n    });\n    MatTextareaAutosize.decorators = [\n        { type: Directive, args: [{\n                    selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n                    exportAs: 'matTextareaAutosize',\n                    inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n                    host: {\n                        'class': 'cdk-textarea-autosize mat-autosize',\n                        // Textarea elements that have the directive applied should have a single row by default.\n                        // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                        'rows': '1',\n                        '(input)': '_noopInputHandler()',\n                    },\n                },] },\n    ];\n    /** @nocollapse */\n    MatTextareaAutosize.propDecorators = {\n        \"matAutosizeMinRows\": [{ type: Input },],\n        \"matAutosizeMaxRows\": [{ type: Input },],\n        \"matAutosize\": [{ type: Input, args: ['mat-autosize',] },],\n        \"matTextareaAutosize\": [{ type: Input },],\n    };\n    return MatTextareaAutosize;\n}(CdkTextareaAutosize));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} type\n * @return {?}\n */\nfunction getMatInputUnsupportedTypeError(type) {\n    return Error(\"Input type \\\"\" + type + \"\\\" isn't supported by matInput.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nvar /** @type {?} */ MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nvar /** @type {?} */ MAT_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit'\n];\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatInputBase = /** @class */ (function () {\n    function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n    return MatInputBase;\n}());\nvar /** @type {?} */ _MatInputMixinBase = mixinErrorState(MatInputBase);\n/**\n * Directive that allows a native input to work inside a `MatFormField`.\n */\nvar MatInput = /** @class */ (function (_super) {\n    __extends(MatInput, _super);\n    function MatInput(_elementRef, _platform, /** @docs-private */\n    ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n        var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n        _this._elementRef = _elementRef;\n        _this._platform = _platform;\n        _this.ngControl = ngControl;\n        _this._autofillMonitor = _autofillMonitor;\n        _this._uid = \"mat-input-\" + nextUniqueId++;\n        /**\n         * Whether the component is being rendered on the server.\n         */\n        _this._isServer = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        _this.focused = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        _this.stateChanges = new Subject();\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        _this.controlType = 'mat-input';\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        _this.autofilled = false;\n        _this._disabled = false;\n        _this._required = false;\n        _this._type = 'text';\n        _this._readonly = false;\n        _this._neverEmptyInputTypes = [\n            'date',\n            'datetime',\n            'datetime-local',\n            'month',\n            'time',\n            'week'\n        ].filter(function (t) { return getSupportedInputTypes().has(t); });\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        _this._inputValueAccessor = inputValueAccessor || _this._elementRef.nativeElement;\n        _this._previousNativeValue = _this.value;\n        // Force setter to be called in case id was not specified.\n        // Force setter to be called in case id was not specified.\n        _this.id = _this.id;\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n        // exists on iOS, we only bother to install the listener on iOS.\n        if (_platform.IOS) {\n            ngZone.runOutsideAngular(function () {\n                _elementRef.nativeElement.addEventListener('keyup', function (event) {\n                    var /** @type {?} */ el = /** @type {?} */ (event.target);\n                    if (!el.value && !el.selectionStart && !el.selectionEnd) {\n                        // Note: Just setting `0, 0` doesn't fix the issue. Setting\n                        // `1, 1` fixes it for the first time that you type text and\n                        // then hold delete. Toggling to `1, 1` and then back to\n                        // `0, 0` seems to completely fix it.\n                        el.setSelectionRange(1, 1);\n                        el.setSelectionRange(0, 0);\n                    }\n                });\n            });\n        }\n        _this._isServer = !_this._platform.isBrowser;\n        return _this;\n    }\n    Object.defineProperty(MatInput.prototype, \"disabled\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            if (this.ngControl && this.ngControl.disabled !== null) {\n                return this.ngControl.disabled;\n            }\n            return this._disabled;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            // Browsers may not fire the blur event if the input is disabled too quickly.\n            // Reset from here to ensure that the element doesn't become stuck.\n            if (this.focused) {\n                this.focused = false;\n                this.stateChanges.next();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"id\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._id; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._id = value || this._uid; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"required\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._required = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"type\", {\n        get: /**\n         * Input type of the element.\n         * @return {?}\n         */\n        function () { return this._type; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._type = value || 'text';\n            this._validateType();\n            // When using Angular inputs, developers are no longer able to set the properties on the native\n            // input element. To ensure that bindings for `type` work, we need to sync the setter\n            // with the native property. Textarea elements don't support the type property or attribute.\n            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n                this._elementRef.nativeElement.type = this._type;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"value\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._inputValueAccessor.value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (value !== this.value) {\n                this._inputValueAccessor.value = value;\n                this.stateChanges.next();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"readonly\", {\n        get: /**\n         * Whether the element is readonly.\n         * @return {?}\n         */\n        function () { return this._readonly; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._readonly = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatInput.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n            _this.autofilled = event.isAutofilled;\n            _this.stateChanges.next();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatInput.prototype.ngOnChanges = /**\n     * @return {?}\n     */\n    function () {\n        this.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatInput.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.stateChanges.complete();\n        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    };\n    /**\n     * @return {?}\n     */\n    MatInput.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n        }\n        // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n        this._dirtyCheckNativeValue();\n    };\n    /** Focuses the input. */\n    /**\n     * Focuses the input.\n     * @return {?}\n     */\n    MatInput.prototype.focus = /**\n     * Focuses the input.\n     * @return {?}\n     */\n    function () { this._elementRef.nativeElement.focus(); };\n    /** Callback for the cases where the focused state of the input changes. */\n    /**\n     * Callback for the cases where the focused state of the input changes.\n     * @param {?} isFocused\n     * @return {?}\n     */\n    MatInput.prototype._focusChanged = /**\n     * Callback for the cases where the focused state of the input changes.\n     * @param {?} isFocused\n     * @return {?}\n     */\n    function (isFocused) {\n        if (isFocused !== this.focused && !this.readonly) {\n            this.focused = isFocused;\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatInput.prototype._onInput = /**\n     * @return {?}\n     */\n    function () {\n        // This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    };\n    /** Does some manual dirty checking on the native input `value` property. */\n    /**\n     * Does some manual dirty checking on the native input `value` property.\n     * @return {?}\n     */\n    MatInput.prototype._dirtyCheckNativeValue = /**\n     * Does some manual dirty checking on the native input `value` property.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ newValue = this.value;\n        if (this._previousNativeValue !== newValue) {\n            this._previousNativeValue = newValue;\n            this.stateChanges.next();\n        }\n    };\n    /** Make sure the input is a supported type. */\n    /**\n     * Make sure the input is a supported type.\n     * @return {?}\n     */\n    MatInput.prototype._validateType = /**\n     * Make sure the input is a supported type.\n     * @return {?}\n     */\n    function () {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n            throw getMatInputUnsupportedTypeError(this._type);\n        }\n    };\n    /** Checks whether the input type is one of the types that are never empty. */\n    /**\n     * Checks whether the input type is one of the types that are never empty.\n     * @return {?}\n     */\n    MatInput.prototype._isNeverEmpty = /**\n     * Checks whether the input type is one of the types that are never empty.\n     * @return {?}\n     */\n    function () {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    };\n    /** Checks whether the input is invalid based on the native validation. */\n    /**\n     * Checks whether the input is invalid based on the native validation.\n     * @return {?}\n     */\n    MatInput.prototype._isBadInput = /**\n     * Checks whether the input is invalid based on the native validation.\n     * @return {?}\n     */\n    function () {\n        // The `validity` property won't be present on platform-server.\n        var /** @type {?} */ validity = (/** @type {?} */ (this._elementRef.nativeElement)).validity;\n        return validity && validity.badInput;\n    };\n    /** Determines if the component host is a textarea. */\n    /**\n     * Determines if the component host is a textarea.\n     * @return {?}\n     */\n    MatInput.prototype._isTextarea = /**\n     * Determines if the component host is a textarea.\n     * @return {?}\n     */\n    function () {\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n    };\n    Object.defineProperty(MatInput.prototype, \"empty\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n                !this.autofilled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatInput.prototype, \"shouldLabelFloat\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this.focused || !this.empty; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    MatInput.prototype.setDescribedByIds = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    function (ids) { this._ariaDescribedby = ids.join(' '); };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    MatInput.prototype.onContainerClick = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () { this.focus(); };\n    MatInput.decorators = [\n        { type: Directive, args: [{\n                    selector: \"input[matInput], textarea[matInput]\",\n                    exportAs: 'matInput',\n                    host: {\n                        /**\n                             * @deletion-target 7.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n                             */\n                        'class': 'mat-input-element mat-form-field-autofill-control',\n                        '[class.mat-input-server]': '_isServer',\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\n                        // the native input element. Otherwise property bindings for those don't work.\n                        '[attr.id]': 'id',\n                        '[attr.placeholder]': 'placeholder',\n                        '[disabled]': 'disabled',\n                        '[required]': 'required',\n                        '[readonly]': 'readonly',\n                        '[attr.aria-describedby]': '_ariaDescribedby || null',\n                        '[attr.aria-invalid]': 'errorState',\n                        '[attr.aria-required]': 'required.toString()',\n                        '(blur)': '_focusChanged(false)',\n                        '(focus)': '_focusChanged(true)',\n                        '(input)': '_onInput()',\n                    },\n                    providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],\n                },] },\n    ];\n    /** @nocollapse */\n    MatInput.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: Platform, },\n        { type: NgControl, decorators: [{ type: Optional }, { type: Self },] },\n        { type: NgForm, decorators: [{ type: Optional },] },\n        { type: FormGroupDirective, decorators: [{ type: Optional },] },\n        { type: ErrorStateMatcher, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] },] },\n        { type: AutofillMonitor, },\n        { type: NgZone, },\n    ]; };\n    MatInput.propDecorators = {\n        \"disabled\": [{ type: Input },],\n        \"id\": [{ type: Input },],\n        \"placeholder\": [{ type: Input },],\n        \"required\": [{ type: Input },],\n        \"type\": [{ type: Input },],\n        \"errorStateMatcher\": [{ type: Input },],\n        \"value\": [{ type: Input },],\n        \"readonly\": [{ type: Input },],\n    };\n    return MatInput;\n}(_MatInputMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatInputModule = /** @class */ (function () {\n    function MatInputModule() {\n    }\n    MatInputModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [MatInput, MatTextareaAutosize],\n                    imports: [\n                        CommonModule,\n                        TextFieldModule,\n                        MatFormFieldModule,\n                    ],\n                    exports: [\n                        TextFieldModule,\n                        MatFormFieldModule,\n                        MatInput,\n                        MatTextareaAutosize,\n                    ],\n                    providers: [ErrorStateMatcher],\n                },] },\n    ];\n    return MatInputModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MatTextareaAutosize, MatInputBase, _MatInputMixinBase, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR };\n//# sourceMappingURL=input.es5.js.map\n",
    "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, Input, Optional, Output, ViewChild, ViewEncapsulation, Inject, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatRipple, mixinColor, mixinDisabled, mixinDisableRipple, mixinTabIndex, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Increasing integer for generating unique ids for radio components.\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return MatRadioGroup; }),\n    multi: true\n};\n/**\n * Change event object emitted by MatRadio and MatRadioGroup.\n */\nvar  /**\n * Change event object emitted by MatRadio and MatRadioGroup.\n */\nMatRadioChange = /** @class */ (function () {\n    function MatRadioChange(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n    return MatRadioChange;\n}());\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatRadioGroupBase = /** @class */ (function () {\n    function MatRadioGroupBase() {\n    }\n    return MatRadioGroupBase;\n}());\nvar /** @type {?} */ _MatRadioGroupMixinBase = mixinDisabled(MatRadioGroupBase);\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\nvar MatRadioGroup = /** @class */ (function (_super) {\n    __extends(MatRadioGroup, _super);\n    function MatRadioGroup(_changeDetector) {\n        var _this = _super.call(this) || this;\n        _this._changeDetector = _changeDetector;\n        /**\n         * Selected value for group. Should equal the value of the selected radio button if there *is*\n         * a corresponding radio button with a matching value. If there is *not* such a corresponding\n         * radio button, this value persists to be applied in case a new radio button is added with a\n         * matching value.\n         */\n        _this._value = null;\n        /**\n         * The HTML name attribute applied to radio buttons in this group.\n         */\n        _this._name = \"mat-radio-group-\" + nextUniqueId++;\n        /**\n         * The currently selected radio button. Should match value.\n         */\n        _this._selected = null;\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        _this._isInitialized = false;\n        /**\n         * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n         */\n        _this._labelPosition = 'after';\n        /**\n         * Whether the radio group is disabled.\n         */\n        _this._disabled = false;\n        /**\n         * Whether the radio group is required.\n         */\n        _this._required = false;\n        /**\n         * The method to be called in order to update ngModel\n         */\n        _this._controlValueAccessorChangeFn = function () { };\n        /**\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\n         * \\@docs-private\n         */\n        _this.onTouched = function () { };\n        /**\n         * Event emitted when the group value changes.\n         * Change events are only emitted when the value changes due to user interaction with\n         * a radio button (the same behavior as `<input type-\"radio\">`).\n         */\n        _this.change = new EventEmitter();\n        return _this;\n    }\n    Object.defineProperty(MatRadioGroup.prototype, \"name\", {\n        get: /**\n         * Name of the radio button group. All radio buttons inside this group will use this name.\n         * @return {?}\n         */\n        function () { return this._name; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._name = value;\n            this._updateRadioButtonNames();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"labelPosition\", {\n        get: /**\n         * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n         * @return {?}\n         */\n        function () {\n            return this._labelPosition;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            this._labelPosition = v === 'before' ? 'before' : 'after';\n            this._markRadiosForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"value\", {\n        get: /**\n         * Value of the radio button.\n         * @return {?}\n         */\n        function () { return this._value; },\n        set: /**\n         * @param {?} newValue\n         * @return {?}\n         */\n        function (newValue) {\n            if (this._value !== newValue) {\n                // Set this before proceeding to ensure no circular loop occurs with selection.\n                this._value = newValue;\n                this._updateSelectedRadioFromValue();\n                this._checkSelectedRadioButton();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatRadioGroup.prototype._checkSelectedRadioButton = /**\n     * @return {?}\n     */\n    function () {\n        if (this._selected && !this._selected.checked) {\n            this._selected.checked = true;\n        }\n    };\n    Object.defineProperty(MatRadioGroup.prototype, \"selected\", {\n        get: /**\n         * Whether the radio button is selected.\n         * @return {?}\n         */\n        function () { return this._selected; },\n        set: /**\n         * @param {?} selected\n         * @return {?}\n         */\n        function (selected) {\n            this._selected = selected;\n            this.value = selected ? selected.value : null;\n            this._checkSelectedRadioButton();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"disabled\", {\n        get: /**\n         * Whether the radio group is disabled\n         * @return {?}\n         */\n        function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            this._markRadiosForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"required\", {\n        get: /**\n         * Whether the radio group is required\n         * @return {?}\n         */\n        function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._required = coerceBooleanProperty(value);\n            this._markRadiosForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     */\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.ngAfterContentInit = /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     * @return {?}\n     */\n    function () {\n        // Mark this component as initialized in AfterContentInit because the initial value can\n        // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n        // NgModel occurs *after* the OnInit of the MatRadioGroup.\n        this._isInitialized = true;\n    };\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     */\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     * @return {?}\n     */\n    MatRadioGroup.prototype._touch = /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     * @return {?}\n     */\n    function () {\n        if (this.onTouched) {\n            this.onTouched();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatRadioGroup.prototype._updateRadioButtonNames = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._radios) {\n            this._radios.forEach(function (radio) {\n                radio.name = _this.name;\n            });\n        }\n    };\n    /**\n     * Updates the `selected` radio button from the internal _value state.\n     * @return {?}\n     */\n    MatRadioGroup.prototype._updateSelectedRadioFromValue = /**\n     * Updates the `selected` radio button from the internal _value state.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // If the value already matches the selected radio, do nothing.\n        var /** @type {?} */ isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n        if (this._radios && !isAlreadySelected) {\n            this._selected = null;\n            this._radios.forEach(function (radio) {\n                radio.checked = _this.value === radio.value;\n                if (radio.checked) {\n                    _this._selected = radio;\n                }\n            });\n        }\n    };\n    /** Dispatch change event with current selection and group value. */\n    /**\n     * Dispatch change event with current selection and group value.\n     * @return {?}\n     */\n    MatRadioGroup.prototype._emitChangeEvent = /**\n     * Dispatch change event with current selection and group value.\n     * @return {?}\n     */\n    function () {\n        if (this._isInitialized) {\n            this.change.emit(new MatRadioChange(/** @type {?} */ ((this._selected)), this._value));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatRadioGroup.prototype._markRadiosForCheck = /**\n     * @return {?}\n     */\n    function () {\n        if (this._radios) {\n            this._radios.forEach(function (radio) { return radio._markForCheck(); });\n        }\n    };\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param value\n     */\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n    MatRadioGroup.prototype.writeValue = /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n    function (value) {\n        this.value = value;\n        this._changeDetector.markForCheck();\n    };\n    /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.registerOnChange = /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    function (fn) {\n        this._controlValueAccessorChangeFn = fn;\n    };\n    /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.registerOnTouched = /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    function (fn) {\n        this.onTouched = fn;\n    };\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param isDisabled Whether the control should be disabled.\n     */\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled Whether the control should be disabled.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.setDisabledState = /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled Whether the control should be disabled.\n     * @return {?}\n     */\n    function (isDisabled) {\n        this.disabled = isDisabled;\n        this._changeDetector.markForCheck();\n    };\n    MatRadioGroup.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-radio-group',\n                    exportAs: 'matRadioGroup',\n                    providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],\n                    host: {\n                        'role': 'radiogroup',\n                        'class': 'mat-radio-group',\n                    },\n                    inputs: ['disabled'],\n                },] },\n    ];\n    /** @nocollapse */\n    MatRadioGroup.ctorParameters = function () { return [\n        { type: ChangeDetectorRef, },\n    ]; };\n    MatRadioGroup.propDecorators = {\n        \"change\": [{ type: Output },],\n        \"_radios\": [{ type: ContentChildren, args: [forwardRef(function () { return MatRadioButton; }), { descendants: true },] },],\n        \"name\": [{ type: Input },],\n        \"labelPosition\": [{ type: Input },],\n        \"value\": [{ type: Input },],\n        \"selected\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"required\": [{ type: Input },],\n    };\n    return MatRadioGroup;\n}(_MatRadioGroupMixinBase));\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatRadioButtonBase = /** @class */ (function () {\n    function MatRadioButtonBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatRadioButtonBase;\n}());\n// As per Material design specifications the selection control radio should use the accent color\n// palette by default. https://material.io/guidelines/components/selection-controls.html\nvar /** @type {?} */ _MatRadioButtonMixinBase = mixinColor(mixinDisableRipple(mixinTabIndex(MatRadioButtonBase)), 'accent');\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\nvar MatRadioButton = /** @class */ (function (_super) {\n    __extends(MatRadioButton, _super);\n    function MatRadioButton(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._changeDetector = _changeDetector;\n        _this._focusMonitor = _focusMonitor;\n        _this._radioDispatcher = _radioDispatcher;\n        _this._animationMode = _animationMode;\n        _this._uniqueId = \"mat-radio-\" + ++nextUniqueId;\n        /**\n         * The unique ID for the radio button.\n         */\n        _this.id = _this._uniqueId;\n        /**\n         * Event emitted when the checked state of this radio button changes.\n         * Change events are only emitted when the value changes due to user interaction with\n         * the radio button (the same behavior as `<input type-\"radio\">`).\n         */\n        _this.change = new EventEmitter();\n        /**\n         * Whether this radio is checked.\n         */\n        _this._checked = false;\n        /**\n         * Value assigned to this radio.\n         */\n        _this._value = null;\n        /**\n         * Unregister function for _radioDispatcher\n         */\n        _this._removeUniqueSelectionListener = function () { };\n        // Assertions. Ideally these should be stripped out by the compiler.\n        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n        // Assertions. Ideally these should be stripped out by the compiler.\n        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n        _this.radioGroup = radioGroup;\n        _this._removeUniqueSelectionListener =\n            _radioDispatcher.listen(function (id, name) {\n                if (id !== _this.id && name === _this.name) {\n                    _this.checked = false;\n                }\n            });\n        return _this;\n    }\n    Object.defineProperty(MatRadioButton.prototype, \"checked\", {\n        get: /**\n         * Whether this radio button is checked.\n         * @return {?}\n         */\n        function () { return this._checked; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var /** @type {?} */ newCheckedState = coerceBooleanProperty(value);\n            if (this._checked !== newCheckedState) {\n                this._checked = newCheckedState;\n                if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n                    this.radioGroup.selected = this;\n                }\n                else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n                    // When unchecking the selected radio button, update the selected radio\n                    // property on the group.\n                    this.radioGroup.selected = null;\n                }\n                if (newCheckedState) {\n                    // Notify all radio buttons with the same name to un-check.\n                    this._radioDispatcher.notify(this.id, this.name);\n                }\n                this._changeDetector.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"value\", {\n        get: /**\n         * The value of this radio button.\n         * @return {?}\n         */\n        function () { return this._value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (this._value !== value) {\n                this._value = value;\n                if (this.radioGroup !== null) {\n                    if (!this.checked) {\n                        // Update checked when the value changed to match the radio group's value\n                        this.checked = this.radioGroup.value === value;\n                    }\n                    if (this.checked) {\n                        this.radioGroup.selected = this;\n                    }\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"labelPosition\", {\n        get: /**\n         * Whether the label should appear after or before the radio button. Defaults to 'after'\n         * @return {?}\n         */\n        function () {\n            return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._labelPosition = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"disabled\", {\n        get: /**\n         * Whether the radio button is disabled.\n         * @return {?}\n         */\n        function () {\n            return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            var /** @type {?} */ newDisabledState = coerceBooleanProperty(value);\n            if (this._disabled !== newDisabledState) {\n                this._disabled = newDisabledState;\n                this._changeDetector.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"required\", {\n        get: /**\n         * Whether the radio button is required.\n         * @return {?}\n         */\n        function () {\n            return this._required || (this.radioGroup && this.radioGroup.required);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._required = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"inputId\", {\n        /** ID of the native input element inside `<mat-radio-button>` */\n        get: /**\n         * ID of the native input element inside `<mat-radio-button>`\n         * @return {?}\n         */\n        function () { return (this.id || this._uniqueId) + \"-input\"; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Focuses the radio button. */\n    /**\n     * Focuses the radio button.\n     * @return {?}\n     */\n    MatRadioButton.prototype.focus = /**\n     * Focuses the radio button.\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.focusVia(this._inputElement.nativeElement, 'keyboard');\n    };\n    /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     */\n    /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     * @return {?}\n     */\n    MatRadioButton.prototype._markForCheck = /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     * @return {?}\n     */\n    function () {\n        // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n        // update radio button's status\n        this._changeDetector.markForCheck();\n    };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        if (this.radioGroup) {\n            // If the radio is inside a radio group, determine if it should be checked\n            this.checked = this.radioGroup.value === this._value;\n            // Copy name from parent radio group\n            this.name = this.radioGroup.name;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._focusMonitor\n            .monitor(this._inputElement.nativeElement)\n            .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\n    };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._inputElement.nativeElement);\n        this._removeUniqueSelectionListener();\n    };\n    /**\n     * Dispatch change event with current value.\n     * @return {?}\n     */\n    MatRadioButton.prototype._emitChangeEvent = /**\n     * Dispatch change event with current value.\n     * @return {?}\n     */\n    function () {\n        this.change.emit(new MatRadioChange(this, this._value));\n    };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype._isRippleDisabled = /**\n     * @return {?}\n     */\n    function () {\n        return this.disableRipple || this.disabled;\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatRadioButton.prototype._onInputClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `radio-button` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    };\n    /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     */\n    /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     * @param {?} event\n     * @return {?}\n     */\n    MatRadioButton.prototype._onInputChange = /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the `change` output.\n        event.stopPropagation();\n        var /** @type {?} */ groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n        this.checked = true;\n        this._emitChangeEvent();\n        if (this.radioGroup) {\n            this.radioGroup._controlValueAccessorChangeFn(this.value);\n            this.radioGroup._touch();\n            if (groupValueChanged) {\n                this.radioGroup._emitChangeEvent();\n            }\n        }\n    };\n    /**\n     * Function is called whenever the focus changes for the input element.\n     * @param {?} focusOrigin\n     * @return {?}\n     */\n    MatRadioButton.prototype._onInputFocusChange = /**\n     * Function is called whenever the focus changes for the input element.\n     * @param {?} focusOrigin\n     * @return {?}\n     */\n    function (focusOrigin) {\n        // TODO(paul): support `program`. See https://github.com/angular/material2/issues/9889\n        if (!this._focusRipple && focusOrigin === 'keyboard') {\n            this._focusRipple = this._ripple.launch(0, 0, { persistent: true });\n        }\n        else if (!focusOrigin) {\n            if (this.radioGroup) {\n                this.radioGroup._touch();\n            }\n            if (this._focusRipple) {\n                this._focusRipple.fadeOut();\n                this._focusRipple = null;\n            }\n        }\n    };\n    MatRadioButton.decorators = [\n        { type: Component, args: [{selector: 'mat-radio-button',\n                    template: \"<label [attr.for]=\\\"inputId\\\" class=\\\"mat-radio-label\\\" #label><div class=\\\"mat-radio-container\\\"><div class=\\\"mat-radio-outer-circle\\\"></div><div class=\\\"mat-radio-inner-circle\\\"></div><div mat-ripple class=\\\"mat-radio-ripple\\\" [matRippleTrigger]=\\\"label\\\" [matRippleDisabled]=\\\"_isRippleDisabled()\\\" [matRippleCentered]=\\\"true\\\" [matRippleRadius]=\\\"23\\\" [matRippleAnimation]=\\\"{enterDuration: 150}\\\"></div></div><input #input class=\\\"mat-radio-input cdk-visually-hidden\\\" type=\\\"radio\\\" [id]=\\\"inputId\\\" [checked]=\\\"checked\\\" [disabled]=\\\"disabled\\\" [tabIndex]=\\\"tabIndex\\\" [attr.name]=\\\"name\\\" [required]=\\\"required\\\" [attr.aria-label]=\\\"ariaLabel\\\" [attr.aria-labelledby]=\\\"ariaLabelledby\\\" [attr.aria-describedby]=\\\"ariaDescribedby\\\" (change)=\\\"_onInputChange($event)\\\" (click)=\\\"_onInputClick($event)\\\"><div class=\\\"mat-radio-label-content\\\" [class.mat-radio-label-before]=\\\"labelPosition == 'before'\\\"><span style=\\\"display:none\\\">&nbsp;</span><ng-content></ng-content></div></label>\",\n                    styles: [\".mat-radio-button{display:inline-block}.mat-radio-label{cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}@media screen and (-ms-high-contrast:active){.mat-radio-checked .mat-radio-inner-circle{border:solid 10px}}.mat-radio-label-content{display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-ripple{position:absolute;left:calc(50% - 25px);top:calc(50% - 25px);height:50px;width:50px;z-index:1;pointer-events:none}\"],\n                    inputs: ['color', 'disableRipple', 'tabIndex'],\n                    encapsulation: ViewEncapsulation.None,\n                    exportAs: 'matRadioButton',\n                    host: {\n                        'class': 'mat-radio-button',\n                        '[class.mat-radio-checked]': 'checked',\n                        '[class.mat-radio-disabled]': 'disabled',\n                        '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                        '[attr.id]': 'id',\n                        // Note: under normal conditions focus shouldn't land on this element, however it may be\n                        // programmatically set, for example inside of a focus trap, in this case we want to forward\n                        // the focus to the native element.\n                        '(focus)': '_inputElement.nativeElement.focus()',\n                    },\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                },] },\n    ];\n    /** @nocollapse */\n    MatRadioButton.ctorParameters = function () { return [\n        { type: MatRadioGroup, decorators: [{ type: Optional },] },\n        { type: ElementRef, },\n        { type: ChangeDetectorRef, },\n        { type: FocusMonitor, },\n        { type: UniqueSelectionDispatcher, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] },] },\n    ]; };\n    MatRadioButton.propDecorators = {\n        \"id\": [{ type: Input },],\n        \"name\": [{ type: Input },],\n        \"ariaLabel\": [{ type: Input, args: ['aria-label',] },],\n        \"ariaLabelledby\": [{ type: Input, args: ['aria-labelledby',] },],\n        \"ariaDescribedby\": [{ type: Input, args: ['aria-describedby',] },],\n        \"checked\": [{ type: Input },],\n        \"value\": [{ type: Input },],\n        \"labelPosition\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"required\": [{ type: Input },],\n        \"change\": [{ type: Output },],\n        \"_ripple\": [{ type: ViewChild, args: [MatRipple,] },],\n        \"_inputElement\": [{ type: ViewChild, args: ['input',] },],\n    };\n    return MatRadioButton;\n}(_MatRadioButtonMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatRadioModule = /** @class */ (function () {\n    function MatRadioModule() {\n    }\n    MatRadioModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, MatRippleModule, MatCommonModule],\n                    exports: [MatRadioGroup, MatRadioButton, MatCommonModule],\n                    declarations: [MatRadioGroup, MatRadioButton],\n                },] },\n    ];\n    return MatRadioModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MatRadioModule, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioChange, MatRadioGroupBase, _MatRadioGroupMixinBase, MatRadioGroup, MatRadioButtonBase, _MatRadioButtonMixinBase, MatRadioButton };\n//# sourceMappingURL=radio.es5.js.map\n",
    "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { animate, state, style, transition, trigger, query, animateChild, group } from '@angular/animations';\nimport { __extends } from 'tslib';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW } from '@angular/cdk/keycodes';\nimport { CdkConnectedOverlay, Overlay, ViewportRuler, OverlayModule } from '@angular/cdk/overlay';\nimport { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Inject, InjectionToken, Input, isDevMode, NgZone, Optional, Output, Self, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { _countGroupLabelsBeforeOption, _getOptionScrollPosition, ErrorStateMatcher, MAT_OPTION_PARENT_COMPONENT, MatOptgroup, MatOption, mixinDisabled, mixinDisableRipple, mixinErrorState, mixinTabIndex, MatCommonModule, MatOptionModule } from '@angular/material/core';\nimport { MatFormField, MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { defer, merge, Subject } from 'rxjs';\nimport { filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The following are all the animations for the mat-select component, with each\n * const containing the metadata for one animation.\n *\n * The values below match the implementation of the AngularJS Material mat-select animation.\n */\nvar /** @type {?} */ matSelectAnimations = {\n    /**\n       * This animation transforms the select's overlay panel on and off the page.\n       *\n       * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it\n       * up to 100% on the Y axis, fades in its border, and translates slightly up and to the\n       * side to ensure the option text correctly overlaps the trigger text.\n       *\n       * When the panel is removed from the DOM, it simply fades out linearly.\n       */\n    transformPanel: trigger('transformPanel', [\n        state('void', style({\n            transform: 'scaleY(0)',\n            minWidth: '100%',\n            opacity: 0\n        })),\n        state('showing', style({\n            opacity: 1,\n            minWidth: 'calc(100% + 32px)',\n            // 32px = 2 * 16px padding\n            transform: 'scaleY(1)'\n        })),\n        state('showing-multiple', style({\n            opacity: 1,\n            minWidth: 'calc(100% + 64px)',\n            // 64px = 48px padding on the left + 16px padding on the right\n            transform: 'scaleY(1)'\n        })),\n        transition('void => *', group([\n            query('@fadeInContent', animateChild()),\n            animate('150ms cubic-bezier(0.25, 0.8, 0.25, 1)')\n        ])),\n        transition('* => void', [\n            animate('250ms 100ms linear', style({ opacity: 0 }))\n        ])\n    ]),\n    /**\n       * This animation fades in the background color and text content of the\n       * select's options. It is time delayed to occur 100ms after the overlay\n       * panel has transformed in.\n       */\n    fadeInContent: trigger('fadeInContent', [\n        state('showing', style({ opacity: 1 })),\n        transition('void => showing', [\n            style({ opacity: 0 }),\n            animate('150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\n        ])\n    ])\n};\n/**\n * @deprecated\n * \\@deletion-target 7.0.0\n */\nvar /** @type {?} */ transformPanel = matSelectAnimations.transformPanel;\n/**\n * @deprecated\n * \\@deletion-target 7.0.0\n */\nvar /** @type {?} */ fadeInContent = matSelectAnimations.fadeInContent;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Returns an exception to be thrown when attempting to change a select's `multiple` option\n * after initialization.\n * \\@docs-private\n * @return {?}\n */\nfunction getMatSelectDynamicMultipleError() {\n    return Error('Cannot change `multiple` mode of select after initialization.');\n}\n/**\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\n * resetting the value.\n * \\@docs-private\n * @return {?}\n */\nfunction getMatSelectNonArrayValueError() {\n    return Error('Value must be an array in multiple-selection mode.');\n}\n/**\n * Returns an exception to be thrown when assigning a non-function value to the comparator\n * used to determine if a value corresponds to an option. Note that whether the function\n * actually takes two values and returns a boolean is not checked.\n * @return {?}\n */\nfunction getMatSelectNonFunctionValueError() {\n    return Error('`compareWith` must be a function.');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * The max height of the select's overlay panel\n */\nvar /** @type {?} */ SELECT_PANEL_MAX_HEIGHT = 256;\n/**\n * The panel's padding on the x-axis\n */\nvar /** @type {?} */ SELECT_PANEL_PADDING_X = 16;\n/**\n * The panel's x axis padding if it is indented (e.g. there is an option group).\n */\nvar /** @type {?} */ SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;\n/**\n * The height of the select items in `em` units.\n */\nvar /** @type {?} */ SELECT_ITEM_HEIGHT_EM = 3;\n/**\n * Distance between the panel edge and the option text in\n * multi-selection mode.\n *\n * (SELECT_PANEL_PADDING_X * 1.5) + 20 = 44\n * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.\n * The checkbox width is 20px.\n */\nvar /** @type {?} */ SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.5 + 20;\n/**\n * The select panel will only \"fit\" inside the viewport if it is positioned at\n * this value or more away from the viewport boundary.\n */\nvar /** @type {?} */ SELECT_PANEL_VIEWPORT_PADDING = 8;\n/**\n * Injection token that determines the scroll handling while a select is open.\n */\nvar /** @type {?} */ MAT_SELECT_SCROLL_STRATEGY = new InjectionToken('mat-select-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_SELECT_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Change event object that is emitted when the select value has changed.\n */\nvar  /**\n * Change event object that is emitted when the select value has changed.\n */\nMatSelectChange = /** @class */ (function () {\n    function MatSelectChange(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n    return MatSelectChange;\n}());\n/**\n * \\@docs-private\n */\nvar  /**\n * \\@docs-private\n */\nMatSelectBase = /** @class */ (function () {\n    function MatSelectBase(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._elementRef = _elementRef;\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n    return MatSelectBase;\n}());\nvar /** @type {?} */ _MatSelectMixinBase = mixinDisableRipple(mixinTabIndex(mixinDisabled(mixinErrorState(MatSelectBase))));\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\nvar MatSelectTrigger = /** @class */ (function () {\n    function MatSelectTrigger() {\n    }\n    MatSelectTrigger.decorators = [\n        { type: Directive, args: [{\n                    selector: 'mat-select-trigger'\n                },] },\n    ];\n    return MatSelectTrigger;\n}());\nvar MatSelect = /** @class */ (function (_super) {\n    __extends(MatSelect, _super);\n    function MatSelect(_viewportRuler, _changeDetectorRef, _ngZone, _defaultErrorStateMatcher, elementRef, _dir, _parentForm, _parentFormGroup, _parentFormField, ngControl, tabIndex, _scrollStrategyFactory) {\n        var _this = _super.call(this, elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n        _this._viewportRuler = _viewportRuler;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._ngZone = _ngZone;\n        _this._dir = _dir;\n        _this._parentFormField = _parentFormField;\n        _this.ngControl = ngControl;\n        _this._scrollStrategyFactory = _scrollStrategyFactory;\n        /**\n         * Whether or not the overlay panel is open.\n         */\n        _this._panelOpen = false;\n        /**\n         * Whether filling out the select is required in the form.\n         */\n        _this._required = false;\n        /**\n         * The scroll position of the overlay panel, calculated to center the selected option.\n         */\n        _this._scrollTop = 0;\n        /**\n         * Whether the component is in multiple selection mode.\n         */\n        _this._multiple = false;\n        /**\n         * Comparison function to specify which option is displayed. Defaults to object equality.\n         */\n        _this._compareWith = function (o1, o2) { return o1 === o2; };\n        /**\n         * Unique id for this input.\n         */\n        _this._uid = \"mat-select-\" + nextUniqueId++;\n        /**\n         * Emits whenever the component is destroyed.\n         */\n        _this._destroy = new Subject();\n        /**\n         * The cached font-size of the trigger element.\n         */\n        _this._triggerFontSize = 0;\n        /**\n         * `View -> model callback called when value changes`\n         */\n        _this._onChange = function () { };\n        /**\n         * `View -> model callback called when select has been touched`\n         */\n        _this._onTouched = function () { };\n        /**\n         * The IDs of child options to be passed to the aria-owns attribute.\n         */\n        _this._optionIds = '';\n        /**\n         * The value of the select panel's transform-origin property.\n         */\n        _this._transformOrigin = 'top';\n        /**\n         * Whether the panel's animation is done.\n         */\n        _this._panelDoneAnimating = false;\n        /**\n         * Strategy that will be used to handle scrolling while the select panel is open.\n         */\n        _this._scrollStrategy = _this._scrollStrategyFactory();\n        /**\n         * The y-offset of the overlay panel in relation to the trigger's top start corner.\n         * This must be adjusted to align the selected option text over the trigger text.\n         * when the panel opens. Will change based on the y-position of the selected option.\n         */\n        _this._offsetY = 0;\n        /**\n         * This position config ensures that the top \"start\" corner of the overlay\n         * is aligned with with the top \"start\" of the origin by default (overlapping\n         * the trigger completely). If the panel cannot fit below the trigger, it\n         * will fall back to a position above the trigger.\n         */\n        _this._positions = [\n            {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'top',\n            },\n            {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'bottom',\n            },\n        ];\n        /**\n         * Whether the component is disabling centering of the active option over the trigger.\n         */\n        _this._disableOptionCentering = false;\n        /**\n         * Whether the select is focused.\n         */\n        _this.focused = false;\n        /**\n         * A name for this control that can be used by `mat-form-field`.\n         */\n        _this.controlType = 'mat-select';\n        /**\n         * Aria label of the select. If not specified, the placeholder will be used as label.\n         */\n        _this.ariaLabel = '';\n        /**\n         * Combined stream of all of the child options' change events.\n         */\n        _this.optionSelectionChanges = defer(function () {\n            if (_this.options) {\n                return merge.apply(void 0, _this.options.map(function (option) { return option.onSelectionChange; }));\n            }\n            return _this._ngZone.onStable\n                .asObservable()\n                .pipe(take(1), switchMap(function () { return _this.optionSelectionChanges; }));\n        });\n        /**\n         * Event emitted when the select panel has been toggled.\n         */\n        _this.openedChange = new EventEmitter();\n        /**\n         * Event emitted when the select has been opened.\n         */\n        _this._openedStream = _this.openedChange.pipe(filter(function (o) { return o; }), map(function () { }));\n        /**\n         * Event emitted when the select has been closed.\n         */\n        _this._closedStream = _this.openedChange.pipe(filter(function (o) { return !o; }), map(function () { }));\n        /**\n         * Event emitted when the selected value has been changed by the user.\n         */\n        _this.selectionChange = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the select changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         * \\@docs-private\n         */\n        _this.valueChange = new EventEmitter();\n        if (_this.ngControl) {\n            // Note: we provide the value accessor through here, instead of\n            // the `providers` to avoid running into a circular import.\n            // Note: we provide the value accessor through here, instead of\n            // the `providers` to avoid running into a circular import.\n            _this.ngControl.valueAccessor = _this;\n        }\n        _this.tabIndex = parseInt(tabIndex) || 0;\n        // Force setter to be called in case id was not specified.\n        // Force setter to be called in case id was not specified.\n        _this.id = _this.id;\n        return _this;\n    }\n    Object.defineProperty(MatSelect.prototype, \"placeholder\", {\n        get: /**\n         * Placeholder to be shown if no value has been selected.\n         * @return {?}\n         */\n        function () { return this._placeholder; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._placeholder = value;\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"required\", {\n        get: /**\n         * Whether the component is required.\n         * @return {?}\n         */\n        function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._required = coerceBooleanProperty(value);\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"multiple\", {\n        get: /**\n         * Whether the user should be allowed to select multiple options.\n         * @return {?}\n         */\n        function () { return this._multiple; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            if (this._selectionModel) {\n                throw getMatSelectDynamicMultipleError();\n            }\n            this._multiple = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"disableOptionCentering\", {\n        get: /**\n         * Whether to center the active option over the trigger.\n         * @return {?}\n         */\n        function () { return this._disableOptionCentering; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._disableOptionCentering = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"compareWith\", {\n        get: /**\n         * A function to compare the option values with the selected values. The first argument\n         * is a value from an option. The second is a value from the selection. A boolean\n         * should be returned.\n         * @return {?}\n         */\n        function () { return this._compareWith; },\n        set: /**\n         * @param {?} fn\n         * @return {?}\n         */\n        function (fn) {\n            if (typeof fn !== 'function') {\n                throw getMatSelectNonFunctionValueError();\n            }\n            this._compareWith = fn;\n            if (this._selectionModel) {\n                // A different comparator means the selection could change.\n                this._initializeSelection();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"value\", {\n        get: /**\n         * Value of the select control.\n         * @return {?}\n         */\n        function () { return this._value; },\n        set: /**\n         * @param {?} newValue\n         * @return {?}\n         */\n        function (newValue) {\n            if (newValue !== this._value) {\n                this.writeValue(newValue);\n                this._value = newValue;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"id\", {\n        get: /**\n         * Unique id of the element.\n         * @return {?}\n         */\n        function () { return this._id; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._id = value || this._uid;\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatSelect.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._selectionModel = new SelectionModel(this.multiple, undefined, false);\n        this.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatSelect.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._initKeyManager();\n        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(function () {\n            _this._resetOptions();\n            _this._initializeSelection();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatSelect.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n    function () {\n        if (this.ngControl) {\n            this.updateErrorState();\n        }\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MatSelect.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let\n        // the parent form field know to run change detection when the disabled state changes.\n        if (changes[\"disabled\"]) {\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatSelect.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroy.next();\n        this._destroy.complete();\n        this.stateChanges.complete();\n    };\n    /** Toggles the overlay panel open or closed. */\n    /**\n     * Toggles the overlay panel open or closed.\n     * @return {?}\n     */\n    MatSelect.prototype.toggle = /**\n     * Toggles the overlay panel open or closed.\n     * @return {?}\n     */\n    function () {\n        this.panelOpen ? this.close() : this.open();\n    };\n    /** Opens the overlay panel. */\n    /**\n     * Opens the overlay panel.\n     * @return {?}\n     */\n    MatSelect.prototype.open = /**\n     * Opens the overlay panel.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this.disabled || !this.options || !this.options.length || this._panelOpen) {\n            return;\n        }\n        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n        // Note: The computed font-size will be a string pixel value (e.g. \"16px\").\n        // `parseInt` ignores the trailing 'px' and converts this to a number.\n        this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement)['font-size']);\n        this._panelOpen = true;\n        this._keyManager.withHorizontalOrientation(null);\n        this._calculateOverlayPosition();\n        this._highlightCorrectOption();\n        this._changeDetectorRef.markForCheck();\n        // Set the font size on the panel element once it exists.\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            if (_this._triggerFontSize && _this.overlayDir.overlayRef &&\n                _this.overlayDir.overlayRef.overlayElement) {\n                _this.overlayDir.overlayRef.overlayElement.style.fontSize = _this._triggerFontSize + \"px\";\n            }\n        });\n    };\n    /** Closes the overlay panel and focuses the host element. */\n    /**\n     * Closes the overlay panel and focuses the host element.\n     * @return {?}\n     */\n    MatSelect.prototype.close = /**\n     * Closes the overlay panel and focuses the host element.\n     * @return {?}\n     */\n    function () {\n        if (this._panelOpen) {\n            this._panelOpen = false;\n            this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n            this._changeDetectorRef.markForCheck();\n            this._onTouched();\n        }\n    };\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param value New value to be written to the model.\n     */\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param {?} value New value to be written to the model.\n     * @return {?}\n     */\n    MatSelect.prototype.writeValue = /**\n     * Sets the select's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param {?} value New value to be written to the model.\n     * @return {?}\n     */\n    function (value) {\n        if (this.options) {\n            this._setSelectionByValue(value);\n        }\n    };\n    /**\n     * Saves a callback function to be invoked when the select's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the value changes.\n     */\n    /**\n     * Saves a callback function to be invoked when the select's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param {?} fn Callback to be triggered when the value changes.\n     * @return {?}\n     */\n    MatSelect.prototype.registerOnChange = /**\n     * Saves a callback function to be invoked when the select's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param {?} fn Callback to be triggered when the value changes.\n     * @return {?}\n     */\n    function (fn) {\n        this._onChange = fn;\n    };\n    /**\n     * Saves a callback function to be invoked when the select is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the component has been touched.\n     */\n    /**\n     * Saves a callback function to be invoked when the select is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param {?} fn Callback to be triggered when the component has been touched.\n     * @return {?}\n     */\n    MatSelect.prototype.registerOnTouched = /**\n     * Saves a callback function to be invoked when the select is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param {?} fn Callback to be triggered when the component has been touched.\n     * @return {?}\n     */\n    function (fn) {\n        this._onTouched = fn;\n    };\n    /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param isDisabled Sets whether the component is disabled.\n     */\n    /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param {?} isDisabled Sets whether the component is disabled.\n     * @return {?}\n     */\n    MatSelect.prototype.setDisabledState = /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param {?} isDisabled Sets whether the component is disabled.\n     * @return {?}\n     */\n    function (isDisabled) {\n        this.disabled = isDisabled;\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    };\n    Object.defineProperty(MatSelect.prototype, \"panelOpen\", {\n        /** Whether or not the overlay panel is open. */\n        get: /**\n         * Whether or not the overlay panel is open.\n         * @return {?}\n         */\n        function () {\n            return this._panelOpen;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"selected\", {\n        /** The currently selected option. */\n        get: /**\n         * The currently selected option.\n         * @return {?}\n         */\n        function () {\n            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSelect.prototype, \"triggerValue\", {\n        /** The value displayed in the trigger. */\n        get: /**\n         * The value displayed in the trigger.\n         * @return {?}\n         */\n        function () {\n            if (this.empty) {\n                return '';\n            }\n            if (this._multiple) {\n                var /** @type {?} */ selectedOptions = this._selectionModel.selected.map(function (option) { return option.viewValue; });\n                if (this._isRtl()) {\n                    selectedOptions.reverse();\n                }\n                // TODO(crisbeto): delimiter should be configurable for proper localization.\n                return selectedOptions.join(', ');\n            }\n            return this._selectionModel.selected[0].viewValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Whether the element is in RTL mode. */\n    /**\n     * Whether the element is in RTL mode.\n     * @return {?}\n     */\n    MatSelect.prototype._isRtl = /**\n     * Whether the element is in RTL mode.\n     * @return {?}\n     */\n    function () {\n        return this._dir ? this._dir.value === 'rtl' : false;\n    };\n    /** Handles all keydown events on the select. */\n    /**\n     * Handles all keydown events on the select.\n     * @param {?} event\n     * @return {?}\n     */\n    MatSelect.prototype._handleKeydown = /**\n     * Handles all keydown events on the select.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (!this.disabled) {\n            this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n        }\n    };\n    /**\n     * Handles keyboard events while the select is closed.\n     * @param {?} event\n     * @return {?}\n     */\n    MatSelect.prototype._handleClosedKeydown = /**\n     * Handles keyboard events while the select is closed.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ keyCode = event.keyCode;\n        var /** @type {?} */ isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||\n            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;\n        var /** @type {?} */ isOpenKey = keyCode === ENTER || keyCode === SPACE;\n        // Open the select on ALT + arrow key to match the native <select>\n        if (isOpenKey || ((this.multiple || event.altKey) && isArrowKey)) {\n            event.preventDefault(); // prevents the page from scrolling down when pressing space\n            this.open();\n        }\n        else if (!this.multiple) {\n            this._keyManager.onKeydown(event);\n        }\n    };\n    /**\n     * Handles keyboard events when the selected is open.\n     * @param {?} event\n     * @return {?}\n     */\n    MatSelect.prototype._handleOpenKeydown = /**\n     * Handles keyboard events when the selected is open.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ keyCode = event.keyCode;\n        var /** @type {?} */ isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n        var /** @type {?} */ manager = this._keyManager;\n        if (keyCode === HOME || keyCode === END) {\n            event.preventDefault();\n            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();\n        }\n        else if (isArrowKey && event.altKey) {\n            // Close the select on ALT + arrow key to match the native <select>\n            event.preventDefault();\n            this.close();\n        }\n        else if ((keyCode === ENTER || keyCode === SPACE) && manager.activeItem) {\n            event.preventDefault();\n            manager.activeItem._selectViaInteraction();\n        }\n        else {\n            var /** @type {?} */ previouslyFocusedIndex = manager.activeItemIndex;\n            manager.onKeydown(event);\n            if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem &&\n                manager.activeItemIndex !== previouslyFocusedIndex) {\n                manager.activeItem._selectViaInteraction();\n            }\n        }\n    };\n    /**\n     * When the panel element is finished transforming in (though not fading in), it\n     * emits an event and focuses an option if the panel is open.\n     */\n    /**\n     * When the panel element is finished transforming in (though not fading in), it\n     * emits an event and focuses an option if the panel is open.\n     * @return {?}\n     */\n    MatSelect.prototype._onPanelDone = /**\n     * When the panel element is finished transforming in (though not fading in), it\n     * emits an event and focuses an option if the panel is open.\n     * @return {?}\n     */\n    function () {\n        if (this.panelOpen) {\n            this._scrollTop = 0;\n            this.openedChange.emit(true);\n        }\n        else {\n            this.openedChange.emit(false);\n            this._panelDoneAnimating = false;\n            this.overlayDir.offsetX = 0;\n            this._changeDetectorRef.markForCheck();\n        }\n    };\n    /**\n     * When the panel content is done fading in, the _panelDoneAnimating property is\n     * set so the proper class can be added to the panel.\n     */\n    /**\n     * When the panel content is done fading in, the _panelDoneAnimating property is\n     * set so the proper class can be added to the panel.\n     * @return {?}\n     */\n    MatSelect.prototype._onFadeInDone = /**\n     * When the panel content is done fading in, the _panelDoneAnimating property is\n     * set so the proper class can be added to the panel.\n     * @return {?}\n     */\n    function () {\n        this._panelDoneAnimating = this.panelOpen;\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * @return {?}\n     */\n    MatSelect.prototype._onFocus = /**\n     * @return {?}\n     */\n    function () {\n        if (!this.disabled) {\n            this.focused = true;\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n     * \"blur\" to the panel when it opens, causing a false positive.\n     */\n    /**\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n     * \"blur\" to the panel when it opens, causing a false positive.\n     * @return {?}\n     */\n    MatSelect.prototype._onBlur = /**\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n     * \"blur\" to the panel when it opens, causing a false positive.\n     * @return {?}\n     */\n    function () {\n        this.focused = false;\n        if (!this.disabled && !this.panelOpen) {\n            this._onTouched();\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * Callback that is invoked when the overlay panel has been attached.\n     */\n    /**\n     * Callback that is invoked when the overlay panel has been attached.\n     * @return {?}\n     */\n    MatSelect.prototype._onAttached = /**\n     * Callback that is invoked when the overlay panel has been attached.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.overlayDir.positionChange.pipe(take(1)).subscribe(function () {\n            _this._changeDetectorRef.detectChanges();\n            _this._calculateOverlayOffsetX();\n            _this.panel.nativeElement.scrollTop = _this._scrollTop;\n        });\n    };\n    /** Returns the theme to be used on the panel. */\n    /**\n     * Returns the theme to be used on the panel.\n     * @return {?}\n     */\n    MatSelect.prototype._getPanelTheme = /**\n     * Returns the theme to be used on the panel.\n     * @return {?}\n     */\n    function () {\n        return this._parentFormField ? \"mat-\" + this._parentFormField.color : '';\n    };\n    Object.defineProperty(MatSelect.prototype, \"empty\", {\n        /** Whether the select has a value. */\n        get: /**\n         * Whether the select has a value.\n         * @return {?}\n         */\n        function () {\n            return !this._selectionModel || this._selectionModel.isEmpty();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatSelect.prototype._initializeSelection = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(function () {\n            _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);\n        });\n    };\n    /**\n     * Sets the selected option based on a value. If no option can be\n     * found with the designated value, the select trigger is cleared.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MatSelect.prototype._setSelectionByValue = /**\n     * Sets the selected option based on a value. If no option can be\n     * found with the designated value, the select trigger is cleared.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    function (value, isUserInput) {\n        var _this = this;\n        if (isUserInput === void 0) { isUserInput = false; }\n        if (this.multiple && value) {\n            if (!Array.isArray(value)) {\n                throw getMatSelectNonArrayValueError();\n            }\n            this._clearSelection();\n            value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\n            this._sortValues();\n        }\n        else {\n            this._clearSelection();\n            var /** @type {?} */ correspondingOption = this._selectValue(value, isUserInput);\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what option the user interacted with last.\n            if (correspondingOption) {\n                this._keyManager.setActiveItem(correspondingOption);\n            }\n        }\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * Finds and selects and option based on its value.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Option that has the corresponding value.\n     */\n    MatSelect.prototype._selectValue = /**\n     * Finds and selects and option based on its value.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Option that has the corresponding value.\n     */\n    function (value, isUserInput) {\n        var _this = this;\n        if (isUserInput === void 0) { isUserInput = false; }\n        var /** @type {?} */ correspondingOption = this.options.find(function (option) {\n            try {\n                // Treat null as a special reset value.\n                return option.value != null && _this._compareWith(option.value, value);\n            }\n            catch (/** @type {?} */ error) {\n                if (isDevMode()) {\n                    // Notify developers of errors in their comparator.\n                    console.warn(error);\n                }\n                return false;\n            }\n        });\n        if (correspondingOption) {\n            isUserInput ? correspondingOption._selectViaInteraction() : correspondingOption.select();\n            this._selectionModel.select(correspondingOption);\n            this.stateChanges.next();\n        }\n        return correspondingOption;\n    };\n    /**\n     * Clears the select trigger and deselects every option in the list.\n     * @param {?=} skip Option that should not be deselected.\n     * @return {?}\n     */\n    MatSelect.prototype._clearSelection = /**\n     * Clears the select trigger and deselects every option in the list.\n     * @param {?=} skip Option that should not be deselected.\n     * @return {?}\n     */\n    function (skip) {\n        this._selectionModel.clear();\n        this.options.forEach(function (option) {\n            if (option !== skip) {\n                option.deselect();\n            }\n        });\n        this.stateChanges.next();\n    };\n    /**\n     * Sets up a key manager to listen to keyboard events on the overlay panel.\n     * @return {?}\n     */\n    MatSelect.prototype._initKeyManager = /**\n     * Sets up a key manager to listen to keyboard events on the overlay panel.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._keyManager = new ActiveDescendantKeyManager(this.options)\n            .withTypeAhead()\n            .withVerticalOrientation()\n            .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe(function () {\n            // Restore focus to the trigger before closing. Ensures that the focus\n            // position won't be lost if the user got focus into the overlay.\n            // Restore focus to the trigger before closing. Ensures that the focus\n            // position won't be lost if the user got focus into the overlay.\n            _this.focus();\n            _this.close();\n        });\n        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe(function () {\n            if (_this._panelOpen && _this.panel) {\n                _this._scrollActiveOptionIntoView();\n            }\n            else if (!_this._panelOpen && !_this.multiple && _this._keyManager.activeItem) {\n                _this._keyManager.activeItem._selectViaInteraction();\n            }\n        });\n    };\n    /**\n     * Drops current option subscriptions and IDs and resets from scratch.\n     * @return {?}\n     */\n    MatSelect.prototype._resetOptions = /**\n     * Drops current option subscriptions and IDs and resets from scratch.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ changedOrDestroyed = merge(this.options.changes, this._destroy);\n        this.optionSelectionChanges\n            .pipe(takeUntil(changedOrDestroyed), filter(function (event) { return event.isUserInput; }))\n            .subscribe(function (event) {\n            _this._onSelect(event.source);\n            if (!_this.multiple && _this._panelOpen) {\n                _this.close();\n                _this.focus();\n            }\n        });\n        // Listen to changes in the internal state of the options and react accordingly.\n        // Handles cases like the labels of the selected options changing.\n        merge.apply(void 0, this.options.map(function (option) { return option._stateChanges; })).pipe(takeUntil(changedOrDestroyed))\n            .subscribe(function () {\n            _this._changeDetectorRef.markForCheck();\n            _this.stateChanges.next();\n        });\n        this._setOptionIds();\n    };\n    /**\n     * Invoked when an option is clicked.\n     * @param {?} option\n     * @return {?}\n     */\n    MatSelect.prototype._onSelect = /**\n     * Invoked when an option is clicked.\n     * @param {?} option\n     * @return {?}\n     */\n    function (option) {\n        var /** @type {?} */ wasSelected = this._selectionModel.isSelected(option);\n        // TODO(crisbeto): handle blank/null options inside multi-select.\n        if (this.multiple) {\n            this._selectionModel.toggle(option);\n            this.stateChanges.next();\n            wasSelected ? option.deselect() : option.select();\n            this._keyManager.setActiveItem(option);\n            this._sortValues();\n            // In case the user select the option with their mouse, we\n            // want to restore focus back to the trigger, in order to\n            // prevent the select keyboard controls from clashing with\n            // the ones from `mat-option`.\n            this.focus();\n        }\n        else {\n            this._clearSelection(option.value == null ? undefined : option);\n            if (option.value == null) {\n                this._propagateChanges(option.value);\n            }\n            else {\n                this._selectionModel.select(option);\n                this.stateChanges.next();\n            }\n        }\n        if (wasSelected !== this._selectionModel.isSelected(option)) {\n            this._propagateChanges();\n        }\n    };\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @return {?}\n     */\n    MatSelect.prototype._sortValues = /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._multiple) {\n            this._selectionModel.clear();\n            this.options.forEach(function (option) {\n                if (option.selected) {\n                    _this._selectionModel.select(option);\n                }\n            });\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * Emits change event to set the model value.\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n    MatSelect.prototype._propagateChanges = /**\n     * Emits change event to set the model value.\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n    function (fallbackValue) {\n        var /** @type {?} */ valueToEmit = null;\n        if (this.multiple) {\n            valueToEmit = (/** @type {?} */ (this.selected)).map(function (option) { return option.value; });\n        }\n        else {\n            valueToEmit = this.selected ? (/** @type {?} */ (this.selected)).value : fallbackValue;\n        }\n        this._value = valueToEmit;\n        this.valueChange.emit(valueToEmit);\n        this._onChange(valueToEmit);\n        this.selectionChange.emit(new MatSelectChange(this, valueToEmit));\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * Records option IDs to pass to the aria-owns property.\n     * @return {?}\n     */\n    MatSelect.prototype._setOptionIds = /**\n     * Records option IDs to pass to the aria-owns property.\n     * @return {?}\n     */\n    function () {\n        this._optionIds = this.options.map(function (option) { return option.id; }).join(' ');\n    };\n    /**\n     * Highlights the selected item. If no option is selected, it will highlight\n     * the first item instead.\n     * @return {?}\n     */\n    MatSelect.prototype._highlightCorrectOption = /**\n     * Highlights the selected item. If no option is selected, it will highlight\n     * the first item instead.\n     * @return {?}\n     */\n    function () {\n        if (this._keyManager) {\n            if (this.empty) {\n                this._keyManager.setFirstItemActive();\n            }\n            else {\n                this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n            }\n        }\n    };\n    /**\n     * Scrolls the active option into view.\n     * @return {?}\n     */\n    MatSelect.prototype._scrollActiveOptionIntoView = /**\n     * Scrolls the active option into view.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ activeOptionIndex = this._keyManager.activeItemIndex || 0;\n        var /** @type {?} */ labelCount = _countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.optionGroups);\n        this.panel.nativeElement.scrollTop = _getOptionScrollPosition(activeOptionIndex + labelCount, this._getItemHeight(), this.panel.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);\n    };\n    /** Focuses the select element. */\n    /**\n     * Focuses the select element.\n     * @return {?}\n     */\n    MatSelect.prototype.focus = /**\n     * Focuses the select element.\n     * @return {?}\n     */\n    function () {\n        this._elementRef.nativeElement.focus();\n    };\n    /**\n     * Gets the index of the provided option in the option list.\n     * @param {?} option\n     * @return {?}\n     */\n    MatSelect.prototype._getOptionIndex = /**\n     * Gets the index of the provided option in the option list.\n     * @param {?} option\n     * @return {?}\n     */\n    function (option) {\n        return this.options.reduce(function (result, current, index) {\n            return result === undefined ? (option === current ? index : undefined) : result;\n        }, undefined);\n    };\n    /**\n     * Calculates the scroll position and x- and y-offsets of the overlay panel.\n     * @return {?}\n     */\n    MatSelect.prototype._calculateOverlayPosition = /**\n     * Calculates the scroll position and x- and y-offsets of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ itemHeight = this._getItemHeight();\n        var /** @type {?} */ items = this._getItemCount();\n        var /** @type {?} */ panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n        var /** @type {?} */ scrollContainerHeight = items * itemHeight;\n        // The farthest the panel can be scrolled before it hits the bottom\n        var /** @type {?} */ maxScroll = scrollContainerHeight - panelHeight;\n        // If no value is selected we open the popup to the first item.\n        var /** @type {?} */ selectedOptionOffset = this.empty ? 0 : /** @type {?} */ ((this._getOptionIndex(this._selectionModel.selected[0])));\n        selectedOptionOffset += _countGroupLabelsBeforeOption(selectedOptionOffset, this.options, this.optionGroups);\n        // We must maintain a scroll buffer so the selected option will be scrolled to the\n        // center of the overlay panel rather than the top.\n        var /** @type {?} */ scrollBuffer = panelHeight / 2;\n        this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);\n        this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);\n        this._checkOverlayWithinViewport(maxScroll);\n    };\n    /**\n     * Calculates the scroll position of the select's overlay panel.\n     *\n     * Attempts to center the selected option in the panel. If the option is\n     * too high or too low in the panel to be scrolled to the center, it clamps the\n     * scroll position to the min or max scroll positions respectively.\n     */\n    /**\n     * Calculates the scroll position of the select's overlay panel.\n     *\n     * Attempts to center the selected option in the panel. If the option is\n     * too high or too low in the panel to be scrolled to the center, it clamps the\n     * scroll position to the min or max scroll positions respectively.\n     * @param {?} selectedIndex\n     * @param {?} scrollBuffer\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    MatSelect.prototype._calculateOverlayScroll = /**\n     * Calculates the scroll position of the select's overlay panel.\n     *\n     * Attempts to center the selected option in the panel. If the option is\n     * too high or too low in the panel to be scrolled to the center, it clamps the\n     * scroll position to the min or max scroll positions respectively.\n     * @param {?} selectedIndex\n     * @param {?} scrollBuffer\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    function (selectedIndex, scrollBuffer, maxScroll) {\n        var /** @type {?} */ itemHeight = this._getItemHeight();\n        var /** @type {?} */ optionOffsetFromScrollTop = itemHeight * selectedIndex;\n        var /** @type {?} */ halfOptionHeight = itemHeight / 2;\n        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the\n        // scroll container, then subtracts the scroll buffer to scroll the option down to\n        // the center of the overlay panel. Half the option height must be re-added to the\n        // scrollTop so the option is centered based on its middle, not its top edge.\n        var /** @type {?} */ optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;\n        return Math.min(Math.max(0, optimalScrollPosition), maxScroll);\n    };\n    Object.defineProperty(MatSelect.prototype, \"_ariaLabel\", {\n        /** Returns the aria-label of the select component. */\n        get: /**\n         * Returns the aria-label of the select component.\n         * @return {?}\n         */\n        function () {\n            // If an ariaLabelledby value has been set, the select should not overwrite the\n            // `aria-labelledby` value by setting the ariaLabel to the placeholder.\n            return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Determines the `aria-activedescendant` to be set on the host. */\n    /**\n     * Determines the `aria-activedescendant` to be set on the host.\n     * @return {?}\n     */\n    MatSelect.prototype._getAriaActiveDescendant = /**\n     * Determines the `aria-activedescendant` to be set on the host.\n     * @return {?}\n     */\n    function () {\n        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n            return this._keyManager.activeItem.id;\n        }\n        return null;\n    };\n    /**\n     * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.\n     * This must be adjusted to align the selected option text over the trigger text when\n     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\n     * can't be calculated until the panel has been attached, because we need to know the\n     * content width in order to constrain the panel within the viewport.\n     * @return {?}\n     */\n    MatSelect.prototype._calculateOverlayOffsetX = /**\n     * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.\n     * This must be adjusted to align the selected option text over the trigger text when\n     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\n     * can't be calculated until the panel has been attached, because we need to know the\n     * content width in order to constrain the panel within the viewport.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ isRtl = this._isRtl();\n        var /** @type {?} */ paddingWidth = this.multiple ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X :\n            SELECT_PANEL_PADDING_X * 2;\n        var /** @type {?} */ offsetX;\n        // Adjust the offset, depending on the option padding.\n        if (this.multiple) {\n            offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;\n        }\n        else {\n            var /** @type {?} */ selected = this._selectionModel.selected[0] || this.options.first;\n            offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;\n        }\n        // Invert the offset in LTR.\n        if (!isRtl) {\n            offsetX *= -1;\n        }\n        // Determine how much the select overflows on each side.\n        var /** @type {?} */ leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));\n        var /** @type {?} */ rightOverflow = overlayRect.right + offsetX - viewportSize.width\n            + (isRtl ? 0 : paddingWidth);\n        // If the element overflows on either side, reduce the offset to allow it to fit.\n        if (leftOverflow > 0) {\n            offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n        }\n        else if (rightOverflow > 0) {\n            offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n        }\n        // Set the offset directly in order to avoid having to go through change detection and\n        // potentially triggering \"changed after it was checked\" errors.\n        this.overlayDir.offsetX = offsetX;\n        this.overlayDir.overlayRef.updatePosition();\n    };\n    /**\n     * Calculates the y-offset of the select's overlay panel in relation to the\n     * top start corner of the trigger. It has to be adjusted in order for the\n     * selected option to be aligned over the trigger when the panel opens.\n     * @param {?} selectedIndex\n     * @param {?} scrollBuffer\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    MatSelect.prototype._calculateOverlayOffsetY = /**\n     * Calculates the y-offset of the select's overlay panel in relation to the\n     * top start corner of the trigger. It has to be adjusted in order for the\n     * selected option to be aligned over the trigger when the panel opens.\n     * @param {?} selectedIndex\n     * @param {?} scrollBuffer\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    function (selectedIndex, scrollBuffer, maxScroll) {\n        var /** @type {?} */ itemHeight = this._getItemHeight();\n        var /** @type {?} */ optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n        var /** @type {?} */ maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);\n        var /** @type {?} */ optionOffsetFromPanelTop;\n        // Disable offset if requested by user by returning 0 as value to offset\n        if (this._disableOptionCentering) {\n            return 0;\n        }\n        if (this._scrollTop === 0) {\n            optionOffsetFromPanelTop = selectedIndex * itemHeight;\n        }\n        else if (this._scrollTop === maxScroll) {\n            var /** @type {?} */ firstDisplayedIndex = this._getItemCount() - maxOptionsDisplayed;\n            var /** @type {?} */ selectedDisplayIndex = selectedIndex - firstDisplayedIndex;\n            // The first item is partially out of the viewport. Therefore we need to calculate what\n            // portion of it is shown in the viewport and account for it in our offset.\n            var /** @type {?} */ partialItemHeight = itemHeight - (this._getItemCount() * itemHeight - SELECT_PANEL_MAX_HEIGHT) % itemHeight;\n            // Because the panel height is longer than the height of the options alone,\n            // there is always extra padding at the top or bottom of the panel. When\n            // scrolled to the very bottom, this padding is at the top of the panel and\n            // must be added to the offset.\n            optionOffsetFromPanelTop = selectedDisplayIndex * itemHeight + partialItemHeight;\n        }\n        else {\n            // If the option was scrolled to the middle of the panel using a scroll buffer,\n            // its offset will be the scroll buffer minus the half height that was added to\n            // center it.\n            optionOffsetFromPanelTop = scrollBuffer - itemHeight / 2;\n        }\n        // The final offset is the option's offset from the top, adjusted for the height\n        // difference, multiplied by -1 to ensure that the overlay moves in the correct\n        // direction up the page.\n        return optionOffsetFromPanelTop * -1 - optionHeightAdjustment;\n    };\n    /**\n     * Checks that the attempted overlay position will fit within the viewport.\n     * If it will not fit, tries to adjust the scroll position and the associated\n     * y-offset so the panel can open fully on-screen. If it still won't fit,\n     * sets the offset back to 0 to allow the fallback position to take over.\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    MatSelect.prototype._checkOverlayWithinViewport = /**\n     * Checks that the attempted overlay position will fit within the viewport.\n     * If it will not fit, tries to adjust the scroll position and the associated\n     * y-offset so the panel can open fully on-screen. If it still won't fit,\n     * sets the offset back to 0 to allow the fallback position to take over.\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    function (maxScroll) {\n        var /** @type {?} */ itemHeight = this._getItemHeight();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ topSpaceAvailable = this._triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;\n        var /** @type {?} */ bottomSpaceAvailable = viewportSize.height - this._triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;\n        var /** @type {?} */ panelHeightTop = Math.abs(this._offsetY);\n        var /** @type {?} */ totalPanelHeight = Math.min(this._getItemCount() * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n        var /** @type {?} */ panelHeightBottom = totalPanelHeight - panelHeightTop - this._triggerRect.height;\n        if (panelHeightBottom > bottomSpaceAvailable) {\n            this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);\n        }\n        else if (panelHeightTop > topSpaceAvailable) {\n            this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);\n        }\n        else {\n            this._transformOrigin = this._getOriginBasedOnOption();\n        }\n    };\n    /**\n     * Adjusts the overlay panel up to fit in the viewport.\n     * @param {?} panelHeightBottom\n     * @param {?} bottomSpaceAvailable\n     * @return {?}\n     */\n    MatSelect.prototype._adjustPanelUp = /**\n     * Adjusts the overlay panel up to fit in the viewport.\n     * @param {?} panelHeightBottom\n     * @param {?} bottomSpaceAvailable\n     * @return {?}\n     */\n    function (panelHeightBottom, bottomSpaceAvailable) {\n        // Browsers ignore fractional scroll offsets, so we need to round.\n        var /** @type {?} */ distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);\n        // Scrolls the panel up by the distance it was extending past the boundary, then\n        // adjusts the offset by that amount to move the panel up into the viewport.\n        this._scrollTop -= distanceBelowViewport;\n        this._offsetY -= distanceBelowViewport;\n        this._transformOrigin = this._getOriginBasedOnOption();\n        // If the panel is scrolled to the very top, it won't be able to fit the panel\n        // by scrolling, so set the offset to 0 to allow the fallback position to take\n        // effect.\n        if (this._scrollTop <= 0) {\n            this._scrollTop = 0;\n            this._offsetY = 0;\n            this._transformOrigin = \"50% bottom 0px\";\n        }\n    };\n    /**\n     * Adjusts the overlay panel down to fit in the viewport.\n     * @param {?} panelHeightTop\n     * @param {?} topSpaceAvailable\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    MatSelect.prototype._adjustPanelDown = /**\n     * Adjusts the overlay panel down to fit in the viewport.\n     * @param {?} panelHeightTop\n     * @param {?} topSpaceAvailable\n     * @param {?} maxScroll\n     * @return {?}\n     */\n    function (panelHeightTop, topSpaceAvailable, maxScroll) {\n        // Browsers ignore fractional scroll offsets, so we need to round.\n        var /** @type {?} */ distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);\n        // Scrolls the panel down by the distance it was extending past the boundary, then\n        // adjusts the offset by that amount to move the panel down into the viewport.\n        this._scrollTop += distanceAboveViewport;\n        this._offsetY += distanceAboveViewport;\n        this._transformOrigin = this._getOriginBasedOnOption();\n        // If the panel is scrolled to the very bottom, it won't be able to fit the\n        // panel by scrolling, so set the offset to 0 to allow the fallback position\n        // to take effect.\n        if (this._scrollTop >= maxScroll) {\n            this._scrollTop = maxScroll;\n            this._offsetY = 0;\n            this._transformOrigin = \"50% top 0px\";\n            return;\n        }\n    };\n    /**\n     * Sets the transform origin point based on the selected option.\n     * @return {?}\n     */\n    MatSelect.prototype._getOriginBasedOnOption = /**\n     * Sets the transform origin point based on the selected option.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ itemHeight = this._getItemHeight();\n        var /** @type {?} */ optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n        var /** @type {?} */ originY = Math.abs(this._offsetY) - optionHeightAdjustment + itemHeight / 2;\n        return \"50% \" + originY + \"px 0px\";\n    };\n    /**\n     * Calculates the amount of items in the select. This includes options and group labels.\n     * @return {?}\n     */\n    MatSelect.prototype._getItemCount = /**\n     * Calculates the amount of items in the select. This includes options and group labels.\n     * @return {?}\n     */\n    function () {\n        return this.options.length + this.optionGroups.length;\n    };\n    /**\n     * Calculates the height of the select's options.\n     * @return {?}\n     */\n    MatSelect.prototype._getItemHeight = /**\n     * Calculates the height of the select's options.\n     * @return {?}\n     */\n    function () {\n        return this._triggerFontSize * SELECT_ITEM_HEIGHT_EM;\n    };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    MatSelect.prototype.setDescribedByIds = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    function (ids) {\n        this._ariaDescribedby = ids.join(' ');\n    };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    MatSelect.prototype.onContainerClick = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this.focus();\n        this.open();\n    };\n    Object.defineProperty(MatSelect.prototype, \"shouldLabelFloat\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */\n        function () {\n            return this._panelOpen || !this.empty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MatSelect.decorators = [\n        { type: Component, args: [{selector: 'mat-select',\n                    exportAs: 'matSelect',\n                    template: \"<div cdk-overlay-origin class=\\\"mat-select-trigger\\\" aria-hidden=\\\"true\\\" (click)=\\\"toggle()\\\" #origin=\\\"cdkOverlayOrigin\\\" #trigger><div class=\\\"mat-select-value\\\" [ngSwitch]=\\\"empty\\\"><span class=\\\"mat-select-placeholder\\\" *ngSwitchCase=\\\"true\\\">{{placeholder || '\\u00A0'}}</span> <span class=\\\"mat-select-value-text\\\" *ngSwitchCase=\\\"false\\\" [ngSwitch]=\\\"!!customTrigger\\\"><span *ngSwitchDefault>{{triggerValue}}</span><ng-content select=\\\"mat-select-trigger\\\" *ngSwitchCase=\\\"true\\\"></ng-content></span></div><div class=\\\"mat-select-arrow-wrapper\\\"><div class=\\\"mat-select-arrow\\\"></div></div></div><ng-template cdk-connected-overlay cdkConnectedOverlayLockPosition cdkConnectedOverlayHasBackdrop cdkConnectedOverlayBackdropClass=\\\"cdk-overlay-transparent-backdrop\\\" [cdkConnectedOverlayScrollStrategy]=\\\"_scrollStrategy\\\" [cdkConnectedOverlayOrigin]=\\\"origin\\\" [cdkConnectedOverlayOpen]=\\\"panelOpen\\\" [cdkConnectedOverlayPositions]=\\\"_positions\\\" [cdkConnectedOverlayMinWidth]=\\\"_triggerRect?.width\\\" [cdkConnectedOverlayOffsetY]=\\\"_offsetY\\\" (backdropClick)=\\\"close()\\\" (attach)=\\\"_onAttached()\\\" (detach)=\\\"close()\\\"><div #panel class=\\\"mat-select-panel {{ _getPanelTheme() }}\\\" [ngClass]=\\\"panelClass\\\" [@transformPanel]=\\\"multiple ? 'showing-multiple' : 'showing'\\\" (@transformPanel.done)=\\\"_onPanelDone()\\\" [style.transformOrigin]=\\\"_transformOrigin\\\" [class.mat-select-panel-done-animating]=\\\"_panelDoneAnimating\\\" [style.font-size.px]=\\\"_triggerFontSize\\\" (keydown)=\\\"_handleKeydown($event)\\\"><div class=\\\"mat-select-content\\\" [@fadeInContent]=\\\"'showing'\\\" (@fadeInContent.done)=\\\"_onFadeInDone()\\\"><ng-content></ng-content></div></div></ng-template>\",\n                    styles: [\".mat-select{display:inline-block;width:100%;outline:0}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper,.mat-form-field-appearance-standard .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-select-panel{outline:solid 1px}}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;transition:none;display:block}\"],\n                    inputs: ['disabled', 'disableRipple', 'tabIndex'],\n                    encapsulation: ViewEncapsulation.None,\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    host: {\n                        'role': 'listbox',\n                        '[attr.id]': 'id',\n                        '[attr.tabindex]': 'tabIndex',\n                        '[attr.aria-label]': '_ariaLabel',\n                        '[attr.aria-labelledby]': 'ariaLabelledby',\n                        '[attr.aria-required]': 'required.toString()',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.aria-invalid]': 'errorState',\n                        '[attr.aria-owns]': 'panelOpen ? _optionIds : null',\n                        '[attr.aria-multiselectable]': 'multiple',\n                        '[attr.aria-describedby]': '_ariaDescribedby || null',\n                        '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',\n                        '[class.mat-select-disabled]': 'disabled',\n                        '[class.mat-select-invalid]': 'errorState',\n                        '[class.mat-select-required]': 'required',\n                        'class': 'mat-select',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(focus)': '_onFocus()',\n                        '(blur)': '_onBlur()',\n                    },\n                    animations: [\n                        matSelectAnimations.transformPanel,\n                        matSelectAnimations.fadeInContent\n                    ],\n                    providers: [\n                        { provide: MatFormFieldControl, useExisting: MatSelect },\n                        { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect }\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    MatSelect.ctorParameters = function () { return [\n        { type: ViewportRuler, },\n        { type: ChangeDetectorRef, },\n        { type: NgZone, },\n        { type: ErrorStateMatcher, },\n        { type: ElementRef, },\n        { type: Directionality, decorators: [{ type: Optional },] },\n        { type: NgForm, decorators: [{ type: Optional },] },\n        { type: FormGroupDirective, decorators: [{ type: Optional },] },\n        { type: MatFormField, decorators: [{ type: Optional },] },\n        { type: NgControl, decorators: [{ type: Self }, { type: Optional },] },\n        { type: undefined, decorators: [{ type: Attribute, args: ['tabindex',] },] },\n        { type: undefined, decorators: [{ type: Inject, args: [MAT_SELECT_SCROLL_STRATEGY,] },] },\n    ]; };\n    MatSelect.propDecorators = {\n        \"trigger\": [{ type: ViewChild, args: ['trigger',] },],\n        \"panel\": [{ type: ViewChild, args: ['panel',] },],\n        \"overlayDir\": [{ type: ViewChild, args: [CdkConnectedOverlay,] },],\n        \"options\": [{ type: ContentChildren, args: [MatOption, { descendants: true },] },],\n        \"optionGroups\": [{ type: ContentChildren, args: [MatOptgroup,] },],\n        \"panelClass\": [{ type: Input },],\n        \"customTrigger\": [{ type: ContentChild, args: [MatSelectTrigger,] },],\n        \"placeholder\": [{ type: Input },],\n        \"required\": [{ type: Input },],\n        \"multiple\": [{ type: Input },],\n        \"disableOptionCentering\": [{ type: Input },],\n        \"compareWith\": [{ type: Input },],\n        \"value\": [{ type: Input },],\n        \"ariaLabel\": [{ type: Input, args: ['aria-label',] },],\n        \"ariaLabelledby\": [{ type: Input, args: ['aria-labelledby',] },],\n        \"errorStateMatcher\": [{ type: Input },],\n        \"id\": [{ type: Input },],\n        \"openedChange\": [{ type: Output },],\n        \"_openedStream\": [{ type: Output, args: ['opened',] },],\n        \"_closedStream\": [{ type: Output, args: ['closed',] },],\n        \"selectionChange\": [{ type: Output },],\n        \"valueChange\": [{ type: Output },],\n    };\n    return MatSelect;\n}(_MatSelectMixinBase));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatSelectModule = /** @class */ (function () {\n    function MatSelectModule() {\n    }\n    MatSelectModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [\n                        CommonModule,\n                        OverlayModule,\n                        MatOptionModule,\n                        MatCommonModule,\n                    ],\n                    exports: [MatFormFieldModule, MatSelect, MatSelectTrigger, MatOptionModule, MatCommonModule],\n                    declarations: [MatSelect, MatSelectTrigger],\n                    providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER]\n                },] },\n    ];\n    return MatSelectModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nexport { MatSelectModule, SELECT_PANEL_MAX_HEIGHT, SELECT_PANEL_PADDING_X, SELECT_PANEL_INDENT_PADDING_X, SELECT_ITEM_HEIGHT_EM, SELECT_MULTIPLE_PANEL_PADDING_X, SELECT_PANEL_VIEWPORT_PADDING, MAT_SELECT_SCROLL_STRATEGY, MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_SELECT_SCROLL_STRATEGY_PROVIDER, MatSelectChange, MatSelectBase, _MatSelectMixinBase, MatSelectTrigger, MatSelect, matSelectAnimations, transformPanel, fadeInContent };\n//# sourceMappingURL=select.es5.js.map\n",
    "<div class=\"mat-form-field-wrapper\"><div class=\"mat-form-field-flex\" #connectionContainer (click)=\"_control.onContainerClick && _control.onContainerClick($event)\"><div class=\"mat-form-field-prefix\" *ngIf=\"_prefixChildren.length\"><ng-content select=\"[matPrefix]\"></ng-content></div><div class=\"mat-form-field-infix\" #inputContainer><ng-content></ng-content><span class=\"mat-form-field-label-wrapper\"><label class=\"mat-form-field-label\" [attr.for]=\"_control.id\" [attr.aria-owns]=\"_control.id\" [class.mat-empty]=\"_control.empty && !_shouldAlwaysFloat\" [class.mat-form-field-empty]=\"_control.empty && !_shouldAlwaysFloat\" [class.mat-accent]=\"color == 'accent'\" [class.mat-warn]=\"color == 'warn'\" #label *ngIf=\"_hasFloatingLabel()\" [ngSwitch]=\"_hasLabel()\"><ng-container *ngSwitchCase=\"false\"><ng-content select=\"mat-placeholder\"></ng-content>{{_control.placeholder}}</ng-container><ng-content select=\"mat-label\" *ngSwitchCase=\"true\"></ng-content><span class=\"mat-placeholder-required mat-form-field-required-marker\" aria-hidden=\"true\" *ngIf=\"!hideRequiredMarker && _control.required && !_control.disabled\">&nbsp;*</span></label></span></div><div class=\"mat-form-field-suffix\" *ngIf=\"_suffixChildren.length\"><ng-content select=\"[matSuffix]\"></ng-content></div></div><div class=\"mat-form-field-underline\" #underline *ngIf=\"appearance != 'outline'\"><span class=\"mat-form-field-ripple\" [class.mat-accent]=\"color == 'accent'\" [class.mat-warn]=\"color == 'warn'\"></span></div><ng-container *ngIf=\"appearance == 'outline'\"><div class=\"mat-form-field-outline\"><div class=\"mat-form-field-outline-start\" [style.width.px]=\"_outlineGapStart\"></div><div class=\"mat-form-field-outline-gap\" [style.width.px]=\"_outlineGapWidth\"></div><div class=\"mat-form-field-outline-end\"></div></div><div class=\"mat-form-field-outline mat-form-field-outline-thick\"><div class=\"mat-form-field-outline-start\" [style.width.px]=\"_outlineGapStart\"></div><div class=\"mat-form-field-outline-gap\" [style.width.px]=\"_outlineGapWidth\"></div><div class=\"mat-form-field-outline-end\"></div></div></ng-container><div class=\"mat-form-field-subscript-wrapper\" [ngSwitch]=\"_getDisplayedMessages()\"><div *ngSwitchCase=\"'error'\" [@transitionMessages]=\"_subscriptAnimationState\"><ng-content select=\"mat-error\"></ng-content></div><div class=\"mat-form-field-hint-wrapper\" *ngSwitchCase=\"'hint'\" [@transitionMessages]=\"_subscriptAnimationState\"><div *ngIf=\"hintLabel\" [id]=\"_hintLabelId\" class=\"mat-hint\">{{hintLabel}}</div><ng-content select=\"mat-hint:not([align='end'])\"></ng-content><div class=\"mat-form-field-hint-spacer\"></div><ng-content select=\"mat-hint[align='end']\"></ng-content></div></div></div>",
    "<div cdk-overlay-origin class=\"mat-select-trigger\" aria-hidden=\"true\" (click)=\"toggle()\" #origin=\"cdkOverlayOrigin\" #trigger><div class=\"mat-select-value\" [ngSwitch]=\"empty\"><span class=\"mat-select-placeholder\" *ngSwitchCase=\"true\">{{placeholder || '\\u00A0'}}</span> <span class=\"mat-select-value-text\" *ngSwitchCase=\"false\" [ngSwitch]=\"!!customTrigger\"><span *ngSwitchDefault>{{triggerValue}}</span><ng-content select=\"mat-select-trigger\" *ngSwitchCase=\"true\"></ng-content></span></div><div class=\"mat-select-arrow-wrapper\"><div class=\"mat-select-arrow\"></div></div></div><ng-template cdk-connected-overlay cdkConnectedOverlayLockPosition cdkConnectedOverlayHasBackdrop cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\" [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\" [cdkConnectedOverlayOrigin]=\"origin\" [cdkConnectedOverlayOpen]=\"panelOpen\" [cdkConnectedOverlayPositions]=\"_positions\" [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\" [cdkConnectedOverlayOffsetY]=\"_offsetY\" (backdropClick)=\"close()\" (attach)=\"_onAttached()\" (detach)=\"close()\"><div #panel class=\"mat-select-panel {{ _getPanelTheme() }}\" [ngClass]=\"panelClass\" [@transformPanel]=\"multiple ? 'showing-multiple' : 'showing'\" (@transformPanel.done)=\"_onPanelDone()\" [style.transformOrigin]=\"_transformOrigin\" [class.mat-select-panel-done-animating]=\"_panelDoneAnimating\" [style.font-size.px]=\"_triggerFontSize\" (keydown)=\"_handleKeydown($event)\"><div class=\"mat-select-content\" [@fadeInContent]=\"'showing'\" (@fadeInContent.done)=\"_onFadeInDone()\"><ng-content></ng-content></div></div></ng-template>"
  ],
  "sourceRoot": ""
}